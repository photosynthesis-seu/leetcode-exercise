# 排序算法

# 冒泡排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
+ 针对所有的元素重复以上的步骤，除了最后一个；
+ 重复步骤1~3，直到排序完成。

2.模板
```C++
void bubbleSort(vector<int>& vec){
    int len = vec.size();
    for(int i=0;i<len-1;i++){//这里小于len-1是因为要顾及后面判断存在vec[i+1]的情况，防止越界。
        bool isSwap = false;//加入isSwap标志，如果某次比较没有发生交换，即说明了已经有序，后面就无须进行遍历了
        //每次冒泡的时候可以少比较数组末尾已经排序好的。因为每一轮冒泡一定会把最大的数放到末尾。
        for(int j=0;j<len-i-1;j++){
            if(vec[j+1]<vec[j]){
                int temp = vec[j];
                vec[j] = vec[j+1];
                vec[j+1] = temp;
            }
        }
        if(!isSwap) return;//这个功能可选
    }
}
```
# 选择排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
+ 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
+ 重复第二步，直到所有元素均排序完毕。

2.模板
```C++
void SelectionSort(vector<int>& vec){
    int len = vec.size();
    for(int i=0;i<len-1;i++){// 总共要经过 len-1 轮比较
        int min = i;
        for(int j=i;j<len;j++){
            if(vec[j]<vec[min]){
                min = j;// 记录目前能找到的最小值元素的下标
            }
        }
        // 将找到的最小值和i位置所在的值进行交换
        if(min != i){
            int temp = vec[i];
            vec[i] = vec[min];
            vec[min] = temp;
        }
    }
}
```
# 插入排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 从第一个元素开始，该元素可以认为已经被排序；
+ 取出下一个元素，在已经排序的元素序列中从后向前扫描；
+ 如果该元素（已排序）大于新元素，将该元素移到下一位置；
+ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
+ 将新元素插入到该位置后；
+ 重复步骤2~5。

2.模板
```C++
void InsertSort(vector<int>& vec){
    int len = vec.size();
    for(int i=1;i<len;i++){
        for(int j=i;j>0;j--){// 从已经排序的序列最右边的开始比较，找到比其小的数
            if(vec[j]<vec[j-1]){
                int temp = vec[j];
                vec[j] = vec[j-1];
                vec[j-1] = temp;
            }
        }
    }
}

```
# 希尔排序

```
平均时间复杂度：O(n^1.3)
空间复杂度：O(1)
```
1.思路

+ 思想来源：插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 1 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了；
+ 希尔排序的「间隔序列」其实是一个超参数，具体不用了解。

2.模板
```C++
void ShellSort(vector<int>& vec){
    int len = vec.size();
    int index = len/2;
    while(index >= 1){
        for(int i=index;i<len;i++){
            for(int j=i-index;j>=0;j-=index){
                if(vec[j]>vec[j+index]){
                    int temp = vec[j];
                    vec[j] = vec[j+index];
                    vec[j+index] = temp;
                }
            }
        }
        index /= 2;
    }
}
```
# 快速排序

```
平均时间复杂度：O(nlogn)
空间复杂度：O(logn)
```

1.思路

+ 从数列中挑出一个元素，称为 “基准”（pivot）;
+ 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
+ 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
+ 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

2.模板
```C++
int Paritition(vector<int>& vec, int low, int high){
    int pivot = vec[low];
    while(low<high){
        while(low<high&&vec[high]>=pivot){
            --high;
        }
        vec[low] = vec[high];
        while(low<high&&vec[low]<=pivot){
            ++low;
        }
        vec[high] = vec[low];
    }
    vec[low] = pivot;
    return low;
}
void QuickSort(vector<int>& vec, int low, int high){
    if(low<high){
        int pivot = Paritition(vec,low,high);
        QuickSort(vec,low,pivot-1);
        QuickSort(vec,pivot+1,high);
    }
}
```
# 归并排序

```
平均时间复杂度：O(nlogn)
空间复杂度：O(n)
```

1.思路

+ 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
  - 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；
  - 自下而上的迭代； 
+ 算法步骤
  - 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
  - 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
  - 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
  - 重复步骤 3 直到某一指针达到序列尾；
  - 将另一序列剩下的所有元素直接复制到合并序列尾。
2.模板
```C++
void Merge(vector<int>& nums, vector<int>& tmp, int l, int r) {
    if (l >= r) {
        return;
    }//相当于归并排序时已经拆分到了单个元素，这时直接返回0.

    int mid = (l + r) / 2;
    Merge(nums, tmp, l, mid) ;
    Merge(nums, tmp, mid + 1, r);//在归并两个有序数组前，首先将这两个数组的逆序对数目进行归并。
    int i = l, j = mid + 1, pos = l;//归并排序的下标处理
    while (i <= mid && j <= r) {//开始对两个有序数组进行归并排序
        if (nums[i] <= nums[j]) {
            tmp[pos] = nums[i];//tmp[]存放归并两个序列后的结果
            ++i;
        }
        else {
            tmp[pos] = nums[j];
            ++j;
        }
        ++pos;
    }
    for (int k = i; k <= mid; ++k) {//如果第2个子区间元素耗尽，第1个子区间还有元素，则全部拷贝入tmp
        tmp[pos++] = nums[k];
    }
    for (int k = j; k <= r; ++k) {//第1个耗尽，第2个子区间还有元素
        tmp[pos++] = nums[k];
    }
    copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);//将每一次归并排序结果拷贝到nums中。
    return;
}

vector<int> MergeSort(vector<int>& nums) {
    int n = nums.size();
    vector<int> tmp(n);
    Merge(nums, tmp, 0, n - 1);
    return nums;

}
```
# 堆排序

```
平均时间复杂度：O(nlogn)
空间复杂度：O(nlogn)
```
1.分析
+ [这篇介绍比较详细](https://blog.csdn.net/u010452388/article/details/81283998)
+ [后面的实现基于这篇](https://www.runoob.com/w3cnote/heap-sort.html)

2.实现
```C++
#include <iostream>
#include <algorithm>
using namespace std;

void max_heapify(int arr[], int start, int end) {
    // 建立父節點指標和子節點指標
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end) { // 若子節點指標在範圍內才做比較
        if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的
            son++;
        if (arr[dad] > arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數
            return;
        else { // 否則交換父子內容再繼續子節點和孫節點比較
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) {
    // 初始化，i從最後一個父節點開始調整
    for (int i = len / 2 - 1; i >= 0; i--)
        max_heapify(arr, i, len - 1);
    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢
    for (int i = len - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main() {
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';
    cout << endl;
    return 0;
}
```
