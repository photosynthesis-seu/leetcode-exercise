# 排序算法

# 冒泡排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
+ 针对所有的元素重复以上的步骤，除了最后一个；
+ 重复步骤1~3，直到排序完成。
2.模板
```C++
void bubbleSort(vector<int>& vec){
    int len = vec.size();
    for(int i=0;i<len-1;i++){//这里小于len-1是因为要顾及后面判断存在vec[i+1]的情况，防止越界。
        //每次冒泡的时候可以少比较数组末尾已经排序好的。因为每一轮冒泡一定会把最大的数放到末尾。
        for(int j=0;j<len-i-1;j++){
            if(vec[j+1]<vec[j]){
                int temp = vec[j];
                vec[j] = vec[j+1];
                vec[j+1] = temp;
            }
        }
    }
}
```
# 选择排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
+ 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
+ 重复第二步，直到所有元素均排序完毕。

2.模板
```C++
void SelectionSort(vector<int>& vec){
    int len = vec.size();
    for(int i=0;i<len-1;i++){// 总共要经过 len-1 轮比较
        int min = i;
        for(int j=i;j<len;j++){
            if(vec[j]<vec[min]){
                min = j;// 记录目前能找到的最小值元素的下标
            }
        }
        // 将找到的最小值和i位置所在的值进行交换
        if(min != i){
            int temp = vec[i];
            vec[i] = vec[min];
            vec[min] = temp;
        }
    }
}
```
# 插入排序
```
平均时间复杂度：O(n^2)
空间复杂度：O(1)
```

1.思路
+ 从第一个元素开始，该元素可以认为已经被排序；
+ 取出下一个元素，在已经排序的元素序列中从后向前扫描；
+ 如果该元素（已排序）大于新元素，将该元素移到下一位置；
+ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
+ 将新元素插入到该位置后；
+ 重复步骤2~5。
2.模板
```C++
void InsertSort(vector<int>& vec){
    int len = vec.size();
    for(int i=1;i<len;i++){
        for(int j=i;j>0;j--){// 从已经排序的序列最右边的开始比较，找到比其小的数
            if(vec[j]<vec[j-1]){
                int temp = vec[j];
                vec[j] = vec[j-1];
                vec[j-1] = temp;
            }
        }
    }
}

```
# 希尔排序

```
平均时间复杂度：O(n^1.3)
空间复杂度：O(1)
```
1.思路

+ 思想来源：插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了；
+ 希尔排序的「间隔序列」其实是一个超参数，这方面有一些研究成果，有兴趣的朋友可以了解一下，但是如果这是面向笔试面试，就不用了解了。

2.模板
```C++
void ShellSort(vector<int>& vec){
    int len = vec.size();
    int index = len/2;
    while(index >= 1){
        for(int i=index;i<len;i++){
            for(int j=i-index;j>=0;j-=index){
                if(vec[j]>vec[j+index]){
                    int temp = vec[j];
                    vec[j] = vec[j+index];
                    vec[j+index] = temp;
                }
            }
        }
        index /= 2;
    }
}
```

