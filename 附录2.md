# 本附录包含题目：
```
面试题08.11.硬币（动态规划/二维数组背包问题）面试题51 数组中的逆序对（归并排序,copy函数，涉及从标准输入设备读取信息！）
面试题56-I 数组中数字出现的次数（位运算与运算符优先级）
面试题57 - II. 和为s的连续正数序列（滑动窗口算法）
No.3 无重复字符的最长子串（双指针、滑窗算法，动态规划，unordered_set）
No.30 串联所有单词的子串（滑窗算法，unordered_map,比较复杂）
No.35 搜索插入位置（带特判的二分查找）
No.39 组合总数（需要列举完全背包问题每种情况/面试题08.11.硬币的细化、回溯算法+剪枝）
No.40 组合总和（回溯算法+巧妙的剪枝）
No.45 跳跃游戏II(贪心算法！自己的递归会超时)
No.46 全排列（递归+回溯算法+DFS）No.61 旋转链表(双指针) No.75 颜色分类 
No.98 验证二叉搜索树（递归helper(root, ower,upper)，中序遍历 ）
No.124 二叉树中的最大路径和（dfs,带返回的递归问题）
No.125 验证回文串（各种内置函数：isdigt/islower/isupper）
No.172 阶乘后的零（数学技巧、腾讯面试题）
No.202 快乐数（数学技巧，unordered_set的使用,双指针的快慢指针算法）
No.225 用队列实现栈 No.232 用栈实现队列(注意循环的判断条件，如果修改栈，就不要用栈的大小判断，很关键！)
No.315 计算右侧小于当前元素的个数(归并算法+vector<pair<int,int>>索引容器) 
No.322 零钱兑换（典型动态规划）
No.365 水壶问题（BFS/DFS、数学问题、lambda表达式、unordered_set重载hash函数）
No.572 另一个树的子树（典型的dfs、KMP字符串匹配算法、哈希树）
No.793 阶乘函数后K个零（二分查找，腾讯面试题变种）
No.983 最低票价（从后向前的动态规划，unordered_set，正确初始化类成员变量）
NO.992 排序数组（各种排序算法！）
No.1095 山脉数组中查找目标值（二分查找）

```
二分查找的一些题目（未做）
```
No.33/No.81 搜索旋转排序数组 No.153/154 搜搜旋转数组中的最小值 No.69 平方根 No.287寻找重复数
No.875 爱吃香蕉的珂珂 No.1300 转变数组后最接近目标值的数组和 No.410 分割数组的最大值
```
滑动窗口的一些题目（未做）
```
No.3 无重复字符的最长子串 No.30 串联所有单词的子串NO.76 最小覆盖子串 No.159 至多包含两个不同字符的最长子串
No.209 长度最小的子数组 No.239 滑动窗口最大值
No.340 至多包含 K 个不同字符的最长子串 No.567 字符串的排列
No.632 最小区间 No.727 最小窗口子序列
```

# 二分查找的模板

[二分查找详细解读的文章](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)
+ 只要看到 left = mid 的时候，就需要调整成为上取整mid = left + (right-left+1)/2。无条件写上 while (left < right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们的值相等。
+ 向左取值的方法
```C++
int main(vector<int>& nums, int target){
int len = nums.size();
        if (len == 0) {
            return 0;
        }
int left = 0;
// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是len。
int right = len;
int res = BinarySearch(nums,target,left,right);
return res;
}
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left)/2 ;// 向左取值
            if (check(mid) < target) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置。
                left = mid + 1;
            } else {
	    	// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
                right = mid;
            }
        }
        return left;
    }
```
+ 向右取值的方法
```C++
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left+1)/2 ;// 向右取值，这里要+1，防止死循环
            if (check(mid)) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
	    	// 只有看到 left = mid 的时候，才需要调整成为上取整，记住这一点即可
                left = mid;
            }
        }
        return left;
    }
```
## 硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

[注意区分排列数与组合数，两者情况不同](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```C++
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析
+ [见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
+ 一种带备忘录的自上而下的实现（递归）

**注意怎么实现带备忘录 -> 使用带返回参数的递归**
```C++
class Solution {
    vector<int>count;
    int dp(vector<int>& coins, int rem) {
        if (rem < 0) return -1;
        if (rem == 0) return 0;
        if (count[rem - 1] != 0) return count[rem - 1];
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res >= 0 && res < Min) {
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount < 1) return 0;
        count.resize(amount);
        return dp(coins, amount);
    }
};
```
+ 一种自下而上的迭代算法

**从0开始，使用循环，注意和自上而下使用递归的区别**
```C++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```
## 数组中的逆序对

1.题目
```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
输入: [7,5,6,4]
输出: 5
```
2.**为了防止两个整型数相加求平均时溢出，我们通常会作如下处理：**
```C++
int i,j;//假设这两个数很大,且j>i
int mid = (i+j)/2;//有可能i+j溢出，不安全
int mid = i+(j-i)/2;更安全的技巧
```

3.**关于copy()函数**

+ copy函数的一些用法：
  - 将数组myints中的七个元素复制到myvector容器中：
  ```C++
  copy (myints, myints+7, myvector.begin());
  ```
  - 将数组myints中的元素向左移动一位:
  ```C++
  copy(myints + 1, myints + 7, myints);
  ```
  - **从标准输入设备读入整数**直到输入的是非整型数据为止;请输入整数序列，按任意非数字键并回车结束输入;输出容器里的所有元素，元素之间用空格隔开:
  ```C++
  #include <algorithm>
  #include <vector>
  #include <iterator>
  #include <string>
  #include<iostream>
  using namespace std；
  int main () 
  {
	 typedef vector<int> IntVector;
	 typedef istream_iterator<int> IstreamItr;
	 typedef ostream_iterator<int> OstreamItr;
	 typedef back_insert_iterator< IntVector > BackInsItr;
	 IntVector myvector;
	 // 从标准输入设备读入整数
	 // 直到输入的是非整型数据为止 请输入整数序列，按任意非数字键并回车结束输入
	 cout << "Please input element：" << endl;
	 copy(IstreamItr(cin), IstreamItr(), BackInsItr(myvector));
	 //输出容器里的所有元素，元素之间用空格隔开
	 cout << "Output : " << endl;
	 copy(myvector.begin(), myvector.end(), OstreamItr(cout, " ")); 
	 cout << endl；
	 return 0;

  }
  ```
+ [copy()函数官方说明文档](https://blog.csdn.net/baidu_41560343/article/details/83095644?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2)
copy函数复制过程是左闭右开的，而且第三个参数是提供另一个有序组的头地址。

4.分析
+ 计算逆序数发生在归并排序的过程中，利用了「排序」以后数组的有序性。
+ 利用「归并排序」计算逆序对，是非常经典的做法；
  - 关键在于「合并两个有序数组」的步骤，利用数组的部分有序性，一下子计算出一个数之前或者之后元素的逆序的个数；
  - 前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数；
  - 「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；
  - 在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。
思想是「分治算法」，所有的「逆序对」来源于 3 个部分：
    - 左边区间的逆序对；
    - 右边区间的逆序对；
    - 横跨两个区间的逆序对。
  - 下面提供两种写法：
1、在第 2 个子区间元素归并回去的时候，计算逆序对的个数；
2、在第 1 个子区间元素归并回去的时候，计算逆序对的个数。
+ 实现
```C++
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }//相当于归并排序时已经拆分到了单个元素，这时直接返回0.

        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);//在归并两个有序数组前，首先将这两个数组的逆序对数目进行归并。
        int i = l, j = mid + 1, pos = l;//归并排序的下标处理
        while (i <= mid && j <= r) {//开始对两个有序数组进行归并排序
            if (nums[i] <= nums[j]) {
                tmp[pos] = nums[i];//tmp[]存放归并两个序列后的结果
                ++i;
                inv_count += (j - (mid + 1));//在第 1 个子区间元素归并回去的时候，计算逆序对的个数
            }
            else {
                tmp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {//如果第2个子区间元素耗尽，第1个子区间还有元素，则全部拷贝入tmp
            tmp[pos++] = nums[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {//第1个耗尽，第2个子区间还有元素
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);//将每一次归并排序结果拷贝到nums中。
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};
```
[官方题解中的视频讲解非常好！](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)

[归并算法实现详解](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/)

## 颜色分类

（荷兰旗问题）

1.题目
```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
2.快速排序

[详细的解读文章](https://blog.csdn.net/qq_28584889/article/details/88136498)
+ 快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：
  - 1、从数列中取出一个数作为基准数（枢轴，pivot）。 
  - 2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。
  - 3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。
+ 实现
```C++
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```


3.分析
+ 算法
  - 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.
  - 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.
  - 初始化当前考虑的元素序号 ：curr = 0.
  - While curr <= p2 :
    - 若 nums[curr] = 0 ：交换第 curr个和第 p0 个元素，并将两个指针都向右移。
    - 若 nums[curr] = 2 ：交换第 curr个和第 p2 个元素，并将p2指针左移 。
    - 若 nums[curr] = 1 ：将指针curr右移。
+ 注意，curr 左边全都是0/1的有序序列！
  - curr位置是0时，与左边的0位置交换，因为保证curr左边全是0/1, 所以交换过来的必然是0/1，状态维持住了；
  - curr位置是2时，交换后，curr不能移动，因为一移动，没法保证交换过来的是0/1；所以这里不移动；这时状态也维持住了
  - 只要我们保证curr左边的都是0,1，才移动，那么0都被放到左边，2都被放到右边，中间自然是1了。
+ 实现
```C++
void sortColors(vector<int>& nums) {
    // 对于所有 idx < p0 : nums[idx < p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > p2 : nums[idx > p2] = 2
    int p2 = nums.size() - 1;
    while (curr <= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
```
## 全排列

1.题目
```
给定一个 没有重复 数字的序列，返回其所有可能的全排列
```
2.分析

**回溯算法的注意事项：其实就是带撤销的递归算法（使用DFS思想）**
+ 使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；
+ 因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；
+ 深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈。
+ 深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。

3.vector中find函数的使用

需要使用迭代器。
```C++
vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
```
4.实现(**注意emplace_back()和find()的使用**)
```C++
class Solution {
public:
    vector<vector<int>> res;
    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(vector<int>& nums, vector<int>& track){
        // 所有数都填完了
        if (track.size() == nums.size()) {
            res.emplace_back(track);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
            track.emplace_back(nums[i]);
            backtrack(nums,track);
            track.pop_back();  
        }
    }
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    vector<vector<int>> permute(vector<int>& nums) {
        if (nums.size() == 0) return {};
	    if (nums.size() == 1) return { {nums[0]} };
        vector<int> track;
        backtrack(nums,track);
        return res;
    }
};
```
5.带备忘录的实现方法
```C++
vector<vector<int> > result;
void func(vector<int> &nums,vector<int> &current, vector<bool>&nums1)
{
	if (current.size() == nums1.size())
		result.push_back(current);
	else
	{
		for (int i = 0; i < nums.size(); i++)
		{
			if (nums1[i])
			{
				current.push_back(nums[i]);
				nums1[i] = false;
				func(nums, current, nums1);
				nums1[i] = true;
				current.pop_back();
			}
		}
	}
}
vector<vector<int>> permute(vector<int>& nums) {
	if (nums.size() == 0)
		return {};
	else if (nums.size() == 1)
		return { {nums[0]} };
	else
	{
		vector<bool> nums1(nums.size(),true);
		vector<int> current;
		func(nums, current, nums1);
		return result;
	}
}
};
```

## 计算右侧小于当前元素的个数

1.题目
```
给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入: [5,2,6,1]
输出: [2,1,1,0] 
```
2.分析
+ 使用归并排序。
  - **本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们可以在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。**
  - 同理，也可以在后有序数组出列时计算。
+ 我们借助计算 “逆序数” 的思路完成本题，关键在于这里我们只能在 “前有序数组” 出列的时候计算逆序数；
如果题目让我们计算 “nums[i] 左侧小于 nums[i] 的元素的数量” 可以在 “后有序数组” 出列的时候计算逆序数；
+ 实现
```C++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int>count;//保存结果
        vector<pair<int,int> > num;//关联每个数和它的序号
        for(int i =0;i<nums.size();++i)
        {
            count.push_back(0);
            num.push_back(make_pair(nums[i],i));//保存每个数和它在原数组中的序号，以免在排序过程中打乱顺序
        }
        merge_sort(num,count);
        return count;
    }
    
    //归并排序
    void merge_sort(vector<pair<int,int> >& vec, vector<int>& count)
    {
        if(vec.size()<2)
            return;
        
        int mid = vec.size()/2;
        vector<pair<int,int> > sub_vec1;
        vector<pair<int,int> > sub_vec2;
        for(int i =0;i<mid;++i)
            sub_vec1.push_back(vec[i]);
        for(int i =mid;i< vec.size();++i)
            sub_vec2.push_back(vec[i]);
        
        merge_sort(sub_vec1,count);
        merge_sort(sub_vec2,count);
        vec.clear();
        merge(sub_vec1,sub_vec2,vec,count);
    }
    
    //合并两数组
    void merge(vector<pair<int,int> >& sub_vec1,vector<pair<int,int> >& sub_vec2, vector<pair<int,int> >& vec,      vector<int>& count)
    {
        int i =0;
        int j =0;
        while(i < sub_vec1.size() && j < sub_vec2.size())
        {
            if(sub_vec1[i].first <= sub_vec2[j].first )
            {
                vec.push_back(sub_vec1[i]);
                count[sub_vec1[i].second] += j;//这句话和下面注释的地方就是这道题和归并排序的主要不同之处
                i++;
            }else{
                vec.push_back(sub_vec2[j]);
                j++;
            }
        }
    }
};
```
## No.125 验证回文串

1.题目
```
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
输入: "A man, a plan, a canal: Panama"
输出: true
```
2.**C++的几个内置函数**
```
islower(char c) 是否为小写字母
isuppper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小
```
3.实现
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        string tmp;
        for (auto c : s) {
            if (islower(c) || isdigit(c))  tmp += c;
            else if (isupper(c)) tmp += (c + 32);
        }
        int i = 0, j = tmp.size() - 1;
        while (i < j) {
            if (tmp[i] != tmp[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};
```
## No.61 旋转链表

1.题目
```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
```
2.分析
![image](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/images/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.png)

3.实现
```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n=0;
        for(auto p=head;p;p=p->next) n++;
        k%=n;
        auto first=head,second=head;
        while(k--){
            first=first->next;
        }
        while(first->next){
            first=first->next;
            second=second->next;
        }
        first->next=head;
        head=second->next;
        second->next=NULL;
        return head;
    }
};
``` 
## No.172 阶乘后的的零
1.题目
```
给定一个整数 n，返回 n! 结果尾数中零的数量。
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
2.分析
+ **对n一直迭代除以5就相当于求n！中5的个数了！！！**
+ 首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。
末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
+ 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...
+ 实现
```C++
    int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}

```
## 阶乘函数后K个零

（**二分查找**）

1.题目
```
f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * ... * x，且0! = 1）
例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。
示例 1:
输入:K = 0
输出:5
解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。
```
2.分析
+ 第一个需要注意的地方，二分法查找时需要注意求最大值最小值的边界处理！
  - 这种求等于某个值的**最左边界**的二分查找需要将**等于号放到大于等于的一边**num = l+(r-l)/2;countzero(num)<K；
  - 这种求某个值的**最右边界**的二分查找需要将**等于号放到小于等于的一边**num = l+(r-l+1)/2;countzero(num)<=K;
    - **一定要注意**如果这个(r-l+1)是为了在只剩两个数时，它们中间的数是右边的数。如果不写，根据判断条件（若l=0,r=1），num一直为0，那就一直循环出不来了！
```C++
 long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;//为了在只剩两个数时，它们中间的数是右边的数。
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }

```
+整体实现
```C++
class Solution {
public:
    const long long MAX_N = 1e15;
    long long countzero(long long num){
        long long res=0;
        while(num){
            res += num/5;
            num /= 5;
        }
        return res;
    }
    long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }
    int preimageSizeFZF(int K) {
        long long left = bisearchLeft(K);
        long long right = bisearchRight(K);
        return (right-left+1);
    }
};
```
## 数组中数字出现的次数

1.题目
```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```
2.运算符优先级的问题

(make_part&sum) == 0，**这里的括号不能少，因为==的优先级大于&**。
```C++
9	==  !=	等于/不等于
10	&	按位与
11	^	按位异或
12	|	按位或
```

3.分析
+ 考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。
+ 那么这一方法如何扩展到找出两个出现一次的数字。如果我们可以把所有数字分成两组，使得：
  - 两个只出现一次的数字在不同的组中；
  - 相同的数字会被分到相同的组中。
那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。
+ 实现：
```C++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int sum = 0;//求全部数组异或的结果
        for(int n:nums){//由于交换律以及异或的性质，最终结果是两个只出现一次的数字的异或的结果。
            sum ^= n;
        }
        int make_part = 1;//寻找一位作为分组时的比较位，这一位应当在异或结果sum中是1，只有这样
        //才可以让两个只出现一次的数字分在不同组。
        while((make_part&sum) == 0){//根据运算符优先级，一定要加括号
            make_part = make_part<<1;
        }
        int a=0,b=0;
        for(int n:nums){//根据比较位，将数组分为两组
            if(make_part&n){//这里不可以写为make_part&n==1!
                a ^= n;
            }
            else{
                b ^= n;
            }
        }
        return (vector<int>{a,b});
    }
};
```
## 二叉树中的最大路径和

1.题目
```
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
2.分析
+ 本题目涉及**带参数的递归调用（DFS）**
+ 递归思想直接看代码
```C++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL) return 0;
        int res = INT_MIN;//现将值设为允许的最小值（万一树节点里面全是负的）。
        dfs(root,res);//直接调用递归函数，只需要确定res，不需要使用返回值。
        return res;
    }
    int dfs(TreeNode* root,int& res){
        if(root == NULL){//DFS遍历到最底层时返回
            return 0;
        }
        int left = max(0,dfs(root->left,res));//确定当前访问节点的左子树的最大路径和
        //注意要和0比较，因为如果小于0我们可以不选择这一条路径，也就是左子树路径为0.
        int right = max(0,dfs(root->right,res));//确定当前访问节点的右子树的最大路径和
        res = max(res,root->val+right+left);//更新最大路径和，因为是当前节点的最大路径和，一定要包括当前节点
        return root->val+max(right,left);//返回时要因为时返回一条路径，
        //所以只能是当前节点和左/右子树选一条路径和大的返回
    }
};
```
## 山脉数组中查找目标值

1.题目
```
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length >= 3
其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
```
2.分析
+ 自然地，求解这道题可以分为 3 步：
  - 第 1 步：先找到山顶元素 mountaintop 所在的索引。
  - 第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；
  - 第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。
+ 注意： 具体编码实现的时候，每一步写一个辅助方法就可以了。这 3 个辅助方法都是二分查找法。
+ 具体实现：
```C++
/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *   public:
 *     int get(int index);
 *     int length();
 * };
 */

class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int len = mountainArr.length();
	//先寻找山顶元素的索引
        int peak = FindMountainPeak(mountainArr,0,len-1);
        int res;
	//在前面升序的数组中找target，如果存在，就返回它的索引.
        res = SearchForwardArray(target,mountainArr,0,peak);
        if(res != -1){
            return res;
        }
	//如果之前的升序数组中无target，则继续查找后面的降序数组，如果存在就返回索引，否则返回-1.
        return SearchReverseArray(target,mountainArr,peak,len-1);
    }
    //查找山顶元素的索引(关键在于比较mid和mid+1处元素值的大小)
    int FindMountainPeak(MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<mountainArr.get(mid+1)){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
    //在前面升序的数组中找target以及其索引，使用向左取值
    int SearchForwardArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
    //查找后面的降序数组的target以及其索引，也是使用向左取值
     int SearchReverseArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)>target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
};
```
## 搜索插入位置

1.题目
```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
输入: [1,3,5,6], 5
输出: 2
```
2.实现

**关注特例判断**
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0){
            return 0;
        }
        // 特判
        if (nums[len - 1] < target) {
            return len;
        }
        int res;
        res = BinarySearch(nums,target,0,len-1);
        return res;

    }
    int BinarySearch(vector<int>& nums,int target,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(nums[mid]<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
};
```
## 快乐数

1.题目
```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
2.注意unordered_set的使用
```C++
unordered_set<int> res;
while(n != 1 && res.find(n) == res.end()){
```
3.分析

+根据我们的探索，我们猜测会有以下三种可能。
  - 最终会得到 1。
  - 最终会进入循环。
  - 值会越来越大，最后接近无穷大。
+ 对于 3 位数的数字，最大是999，它做各位平方和运算后为243.因此它不可能大于 243。**这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止**。所以我们知道，最坏的情况下，算法可能会在 2243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。**但它不会无限期地进行下去，所以我们排除第三种选择**。
+ 因此，可以使用 哈希Set 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。如果它不在 HashSet 中，我们应该添加它。如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。

4.实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> res;
        while(n != 1 && res.find(n) == res.end()){
        res.insert(n);
        n = SquareSum(n);
        }
        if(n==1){
            return true;
        }
        else{
            return false;
        }
    }
};
```
5.快慢指针算法(**双指针思想！**)

+ 通过反复调用 SquareSum(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 SquareSum(n) 函数获得。意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。
+ 我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 SquareSum(n) 函数的嵌套调用）。
  - 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
  - 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。
+ 实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        int SlowRunner = n;
        int FastRunner = SquareSum(n);
        while(FastRunner != 1 && FastRunner != SlowRunner){
        SlowRunner = SquareSum(SlowRunner);
        FastRunner = SquareSum(SquareSum(FastRunner));
        }
        return FastRunner == 1; 
    }
};
```
## 排序数组

1.题目
```
给你一个整数数组 nums，请你将该数组升序排列。
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```
2.分析
+ 最简单的实现：调用sort函数
```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==0){
            return {};
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```
## 用队列实现栈

1.题目
```
使用队列实现栈的下列操作：
push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
```
2.分析
+ 维护队列使其队头对应栈的栈顶，队尾对应栈的栈底。则需要在每次在队列尾部加入元素之后将原本就有的res.size() - 1个元素从头取出放回尾部以使队头对应栈顶，队尾对应栈底。
+ 实现
```C++
 queue<int> res;
    /** Initialize your data structure here. */
    MyStack() = default;   
    /** Push element x onto stack. */
    void push(int x) {
        res.push(x);
        for(int i=0;i<res.size()-1;i++){
            res.push(res.front());
            res.pop();
        }
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = res.front();
        res.pop();
        return tmp;
    }
    /** Get the top element. */
    int top() {
        return res.front();
    }  
    /** Returns whether the stack is empty. */
    bool empty() {
        return res.empty();
    }
```
## 用栈实现队列

1.题目
```
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```
2.分析
+ 用两个栈实现！**一定要注意在出栈时栈的大小不能作循环条件！需要使用栈是否为空作为判断依据**
```c++
stack<int> res;
stack<int> temp;
// for(int i=0;i<res.size();i++){
//     temp.push(res.top());
//     res.pop();
// }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
 while(!res.empty()){
     temp.push(res.top());
     res.pop();
 }
```
+ 实现
```c++
stack<int> res;
    /** Initialize your data structure here. */
    MyQueue() = default;
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stack<int> temp;
        // for(int i=0;i<res.size();i++){
        //     temp.push(res.top());
        //     res.pop();
        // }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
        while(!res.empty()){
            temp.push(res.top());
            res.pop();
        }
        res.push(x);
    //     for(int j=0;j<temp.size();j++){
    //         res.push(temp.top());
    //         temp.pop();
    //     }
        while(!temp.empty()){
            res.push(temp.top());
            temp.pop();
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        int tmp = res.top();
        res.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        return res.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return res.empty();
    }
```
## 无重复字符的最长子串

1. 题目
```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
2.分析
+ 双指针、滑窗优化算法：
  - 创建一个左指针和一个右指针均指向s[0]，左指针先不动，移动右指针并计算子串长度；当出现重复字符时，向右移动左指针直至没有重复字符。子串存储在unordered_set中。
  - 部分实现
  ```C++
  for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
  ```
  - 这个while是滑窗（双指针）算法的精髓，在hashset中一直存在右指针指向的值时，一直将左指针向右移动，并删除hashset中左指针对应的值，这样做是合理的，不影响最长子串的确定。
+ 整体实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.length();
        if(len == 0) return 0;
        unordered_set<char> uset;//存储不包含重复字符的子串
        int res = 0;
        int left = 0;//滑窗中的左指针
        for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
        return res;
    }
};
```
3.动态规划算法（麻烦一些）
+ dp[i]表示以第i个字符结尾的无重复字符子串的长度。比如 abcbc :
```C++
dp[0] = 1;  "a"
dp[1] = 2;  "ab"
dp[2] = 3;  "abc"
dp[3] = 2;  "cb"
dp[4] = 2;  "bc"
```
+ 初始值：对于第一个字符，dp[0] = 1
+ 状态转移：对于第i个字符，如果在dp[i-1]所代表的子串中出现，那么从所出现的位置j的下一个位置到i，构成了以i结尾的不重复子串。即dp[i] = i-j;
如果第i个字符不在前面的dp[i-1]子串中出现，那么i-1子串加上i字符构成了i子串，因此 dp[i] = dp[i-1]+1。那么需要担心j位置后又出现了字符i吗？不需要，因为前面的子串本身就是不重复的，不可能存在两个字符i。
+ 最大值： 返回 max(dp[i])。
+ 空间优化：由于只需要知道前一个子串的长度，因此仅需记录 lastLen。
+ 实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int size = (int)s.size();
        if(size==0){
            return 0;
        } 
        int lastLen = 1;
        int max = 1;
        int curLen = 0;
        for(int i=1; i<size; ++i){
            curLen = 0;
            for(int j=i-lastLen; j<=i-1; ++j){
                if(s[j]==s[i]){
                    curLen = i-j;
                    break;
                }
            }
            if(curLen==0){
                curLen = lastLen + 1;
            }
            
            if(curLen>max){
                max = curLen;
            }

            lastLen = curLen;
        }
        return max;
    }
};
```
## 串联所有单词的子串

1.题目
```

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```
2.一些技巧

+ substr()的使用：两个参数分别为字符串中子串的起始和终止位置。
```C++
 string temp_str = s.substr(j,word_size);
```
+ unordered_map键的赋值语句:
```C++
for(auto word:words){
       m1[word]++;
   } 
```


3.分析

+ 用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（**因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他**）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。
  - 因为单词的长度 len 是固定的，所以可以将一个单词看成一个单元
  - 对单词使用滑动窗口，单元间的步长就是 len
  - 在 0 - len 的范围内，每一个都作为滑动窗口的起点，滑动 len 次，即可覆盖所有字符串的各种组合
+ 实现
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        if(words.size() == 0)//判断words为空,因为下面用到了words[0]
            return res;
        
        int word_size = words[0].size();
        int word_num = words.size();
        
        unordered_map<string,int> m1;//构造hashmap
        for(int i=0;i<word_num;i++){
            m1[words[i]]++;
        }
        //注意也可以用auto修饰符
        // for(auto word:words){
        //     m1[word]++;
        // }    
        unordered_map<string,int> m2;//统计滑窗中的单词
        for(int i=0; (i + word_size * word_num) <= s.size() ; i++){//截取的s符合题意
            int j = 0;
            for(j=i;j < (i + word_size * word_num) ; j=j+word_size){//分段判断
                string temp_str = s.substr(j,word_size);
                if(m1[temp_str] == 0){//m1中没有截取的串，直接跳出
                    break;
                }else{
                    m2[temp_str]++;
                    if(m1[temp_str] < m2[temp_str])//滑窗中单词出现次数超过了m1，也跳出
                        break;
                }
            }
            
            if(j == (i + word_size * word_num))//每一段都符合，则加入答案
                ret.push_back(i);
            
            m2.clear();//清空m2,开始下一个滑窗
        }
        return res;
    }
};

```
## 组合总数

1.题目
```

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```
2.分析

[这篇解答很棒](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)
+ 还是那个回溯算法框架
```C++
void backtrack(路径，选择列表){
    if(满足结束条件){
        result.add(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}
```
+ 以 target 为根结点，每一个分支做减法；
  - 减到 0 或者负数的时候，到了叶子结点；
  - 减到 0 的时候结算，这里 “结算” 的意思是添加到结果集；
  - 从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。
+ **剪枝去重复**
  - 在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点以本层减去的数作为搜索起点开始搜索；
  - 在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;// 从根结点到任意结点的选择路径
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(0,candidates,target);
        return res;
    }

    void dfs(int start, vector<int>& candidates, int target ){
        if(target == 0){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size();i++){
            //因为candidates排序了，当前的值都比target大，之后的一定也更大，所以直接返回
            if(target - candidates[i] < 0) return;
            path.push_back(candidates[i]);//做选择
            //注意，剪枝的核心在于起点搜索下标为i,根据深度优先树，比i小的下标的值，之前都已经深度遍历多了
            dfs(i,candidates,target-candidates[i]);
            path.pop_back();//撤销选择
        }
    }
};
```
## 组合总和

1.题目
```

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
2.分析
+ 依然是回溯算法+剪枝，注意和NO.39比较
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        if(candidates.size()==0) return {};
        dfs(candidates,target,0);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start){
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i=start;i<candidates.size();i++){
            if(target-candidates[i]<0){
                return;
            } 
            if(i>start&&candidates[i] == candidates[i-1]) continue;//仔细思考，关键的剪枝判断！
            path.push_back(candidates[i]);
            dfs(candidates,target-candidates[i],i+1);
            path.pop_back();
        }
    }
};
```
## 跳跃游戏II

**关注贪心算法！**

1.题目
```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
2.分析

+ 自己的递归算法会超时，递归条件如果也要贪心算法的话，就没必要递归了。
+ 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。
  - 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。
  - 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。
+ 实现
```C++
int jump(vector<int> &nums){
        int ans = 0;
        int start = 0;
        int end = 1;
        while (end < nums.size()){
            int maxPos = 0;
            for (int i = start; i < end; i++){
                // 能跳到最远的距离
                maxPos = max(maxPos, i + nums[i]);
            }
            start = end;      // 下一次起跳点范围开始的格子
            end = maxPos + 1; // 下一次起跳点范围结束的格子
            ans++;            // 跳跃次数
        }
        return ans;
    } 
```

## 和为s的连续正数序列

1.题目
```
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

输入：target = 9
输出：[[2,3,4],[4,5]]
```
2.分析

+ 要用滑动窗口解这道题，我们要回答两个问题：第一个问题，窗口何时扩大，何时缩小？第二个问题，滑动窗口能找到全部的解？
+ 对于第一个问题：
  - 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动。
  - 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动。
  - 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为[i,j]，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。
+ 第二个证明是显然的，因为序列是等差单增的。
+ 实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。
+ 实现：
```C++
vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int left = 1;//左指针（左边界）
        int right = 1;//右指针（右边界）
        int sum = 0;
        while(left<=target/2){//题目要求一个序列至少包含两个数，所以左滑窗到target一半即可。
            if(sum<target){
                sum += right;
                right++;
            }
            else if(sum>target){
                sum -=left;
                left++;
            }
            else{//滑窗内和为target
                vector<int> temp;
                for(int i=left;i<right;i++){
                    temp.push_back(i);
                }
                res.push_back(temp);
                sum -= left;//向右移动左指针，注意和下一句顺序不能反。
                left++;   
            }
        }
        return res;
    }
```
## 验证二叉搜索树

**关注中序遍历二叉树的实现！！，关注此题递归函数的退出条件！！**

1.题目
```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

输入:
    2
   / \
  1   3
输出: true
```
2.分析

+ 由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
+ 这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。
+ 那么根据二叉搜索树的性质，在递归调用左子树时，需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。
+ 函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。
+ 实现
```C++
 bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;//关注递归函数返回为真的判断！即遍历到底nullptr也没出错！！
        if (root -> val <= lower || root -> val >= upper) return false;
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);//关注起始时的最大最小值
    }
```
3.中序遍历方法
```C++
  //关注栈的使用
  bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) return false;
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }

```
或者
```C++
class Solution {
public :
    long pre = MIN_LONG;
    boolean isValidBST(TreeNode* root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root->left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root->val <= pre) {
            return false;
        }
        pre = root->val;
        // 访问右子树
        return isValidBST(root->right);
    }
}
```
## 最低票价

1.题目
```
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
一张为期一天的通行证售价为 costs[0] 美元；
一张为期七天的通行证售价为 costs[1] 美元；
一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```
2.**需要正确地在类中初始化vector成员变量**

+ **错误方法**
```C++
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
```
+ **正确方法**
```C++
//C++11后
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
//C++11之前
class Foo {
public:
    vector<string> name;
    vector<int> val;
    Foo() : name(5), val(5,0) {}
};
```


3.分析

+ 用 dp(i) 来表示从第 i 天开始到一年的结束，需要花的钱。考虑到一张通行证可以让我们在「接下来」的若干天进行旅行，所以**「从后往前」**倒着进行动态规划。**代码中的体现就是主函数中dp函数从dp(1)开始**
+ 对于一年中的任意一天：
  - 如果这一天不是必须出行的日期，可以贪心地选择不买。这是因为如果今天不用出行，那么也不必购买通行证，并且通行证越晚买越好。所以有 dp(i)=dp(i+1)；
  - 如果这一天是必须出行的日期，可以选择买 1，7 或 30 天的通行证。若购买了 j 天的通行证，那么接下来的 j−1 天，都不再需要购买通行证，只需要考虑第 i+j 天及以后即可。因此有： dp(i)=min{cost(j)+dp(i+j)},j∈{1,7,30}. 其中 cost(j) 表示 j 天通行证的价格;
+ 由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366 的数组（因为天数是[1,365]，而数组的下标是从 0 开始的）存储所有的动态规划结果，这样所有的 dp(i) 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。
+ 实现
```C++
unordered_set<int> travaldays;//保存旅行日期
    vector<int> memo;//类成员不能直接初始化，要在成员函数里初始化！
    vector<int> costs;//全局声明，这样dp函数就可以直接用了，不用传参costs[]。
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        memo.resize(366,-1);//记录从任意一天开始旅行的最小花费
        this->costs = costs;
        for(auto tarvelday : days){
            travaldays.insert(tarvelday);
        }
        int result = dp(1);//从后往前递归和动态规划
        return result;
    }
    int dp(int startday){
        if(startday > 365){
            return 0;
        }
        if(memo[startday] != -1){
            return memo[startday];
        }
        if(!travaldays.count(startday)){
            //注意这里是dp(startday+1)不是memo[startday+1],因为是从后往前动态规划，要先把后面动态规划的值求出来
            memo[startday] = dp(startday+1);
        }
        else{
            memo[startday] = min(dp(startday+1)+costs[0],min(dp(startday+7)+costs[1],dp(startday+30)+costs[2]));
        }
        return memo[startday];
    }
```
## 水壶问题

1.题目
```
有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。
你允许：
装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空

输入: x = 3, y = 5, z = 4
输出: True
```
2.**lambda函数与表达式**：

+ C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下：
```C++
[capture](parameters) mutable ->return-type{statement};
//例如
[](int x, int y){ return x < y ; };
[](int x, int y) -> int { int z = x + y; return z + x; };
```
+ [capture]：捕捉列表。捕捉列表总是出现在 lambda 表达式的开始处。事实上，[] 是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数。捕捉列表能够捕捉上下文中的变量供 lambda 函数使用。
```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```
+ (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号 () 一起省略。
+ mutable：mutable 修饰符。默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。
+ ->return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号 -> 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。
+ {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

3.**decltype 关键字**

+ 官方说明
```
decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto是有一些区别的。
decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，
返回该表达式的类型,而且decltype并不会对表达式进行求值。

decltype关键字用于查询表达式的类型，并不会对表达式进行求值。
decltype的作用是获得一个变量或表达式的类型。
decltype 不会执行表达式而auto会，decltype仅仅推论一下表达式的类型。
```
+ 对于decltype(e)而言，其判别结果受以下条件的影响：
  - 如果e是一个标识符或者类成员的访问表达式，则decltype(e)就是e所代表的实体的类型。如果没有这种类型或者e是一个重载函数集，那么程序是错误的；
  - 如果e是一个函数调用或者一个重载操作符调用(忽略e外面的括号)，那么decltype(e)就是该函数的返回类型；
  - 如果e不属于以上所述的情况，则假设e的类型是 T：当e是一个左值时，decltype(e)就是T&；否则(e是一个右值)，decltype(e)是T。
+ 一些例子：
```C++
#include "decltype.hpp"
#include <iostream>
#include <string>
#include <utility>
#include <iomanip>
 
//////////////////////////////////////////////
// reference: http://en.cppreference.com/w/cpp/language/decltype
struct A { double x; };
const A* a = new A{ 0 };
 
decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
 
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u); // return type depends on template parameters
 
int test_decltype1()
{
	int i = 33;
	decltype(i) j = i * 2;
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	auto f = [](int a, int b) -> int
	{
		return a * b;
	};
 
	decltype(f) g = f; // the type of a lambda function is unique and unnamed
	i = f(2, 2);
	j = g(3, 3);
 
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	return 0;
}
```
4.分析

+ 在任意一个时刻，此问题的状态可以由两个数字决定：X 壶中的水量，以及 Y 壶中的水量。在任意一个时刻，我们可以且仅可以采取以下几种操作：
  - 把 X 壶的水灌进 Y 壶，直至灌满或倒空；
  - 把 Y 壶的水灌进 X 壶，直至灌满或倒空；
  - 把 X 壶灌满；
  - 把 Y 壶灌满；
  - 把 X 壶倒空；
  - 把 Y 壶倒空。
+ 因此，本题可以使用深度优先搜索来解决。搜索中的每一步以 remain_x, remain_y 作为状态，即表示 X 壶和 Y 壶中的水量。在每一步搜索时，我们会依次尝试所有的操作，递归地搜索下去。这可能会导致我们陷入无止境的递归，因此我们还需要使用一个哈希结合（HashSet）存储所有已经搜索过的 remain_x, remain_y 状态，保证每个状态至多只被搜索一次。
+ 实现
```C++
using PII = pair<int, int>;

class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        stack<PII> stk;
        stk.emplace(0, 0);
        auto hash_function = [](const PII& o) {return hash<int>()(o.first) ^ hash<int>()(o.second);};
        unordered_set<PII, decltype(hash_function)> seen(0, hash_function);
        while (!stk.empty()) {
            if (seen.count(stk.top())) {
                stk.pop();
                continue;
            }
            seen.emplace(stk.top());
            
            auto [remain_x, remain_y] = stk.top();
            stk.pop();
            if (remain_x == z || remain_y == z || remain_x + remain_y == z) {
                return true;
            }
            // 把 X 壶灌满。
            stk.emplace(x, remain_y);
            // 把 Y 壶灌满。
            stk.emplace(remain_x, y);
            // 把 X 壶倒空。
            stk.emplace(0, remain_y);
            // 把 Y 壶倒空。
            stk.emplace(remain_x, 0);
            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stk.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));
            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stk.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));
        }
        return false;
    }
};
```
5.数学方法

+ 我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得ax+by=z
  - 而只要满足 z≤x+y，且这样的 a, ba,b 存在，那么我们的目标就是可以达成的。这是因为：
  - 若 a≥0,b≥0，那么显然可以达成目标。
  - 若 a<0，那么可以进行以下操作：
    - 往 y 壶倒水；
    - 把 y 壶的水倒入 x 壶；
    - 如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。
  - 重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。
  - 若 b<0，方法同上，x 与 y 互换。
+ 根据贝祖定理，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。
+ 实现
```C++
    bool canMeasureWater(int x, int y, int z) {
        if (x + y < z) return false;
        if (x == 0 || y == 0) return z == 0 || x + y == z;
        return z % gcd(x, y) == 0;
    }
```
## 另一个树的子树

1.题目
```
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true
```
2.方法一（dfs+递归）

+ 一个树是另一个树的子树，那么即有：
  - 要么这两个树相等
  - 要么这个树是左树的子树
  - 要么这个树是右树的子树
+ 基于dfs和递归对每一个节点进行判断，**注意dfs遍历二叉树，就是前序遍历，参考No.98/105**
+ 实现
```C++
    bool isSametree(TreeNode* s, TreeNode* t){//判断两棵树是否相等
        if(s == nullptr&&t == nullptr){
            return true;//递归的返回条件，均空自然之前全相等，所以返回真。
        }
        return s&&t
                && s->val == t->val
                && isSametree(s->left,t->left)//递归判断
                && isSametree(s->right,t->right);
    }
    bool isSubtree(TreeNode* s, TreeNode* t) {//判断t是否是s的子树
        if(s == nullptr&&t == nullptr){
            return true;
        }
        if(s == nullptr&&t != nullptr){
            return false;
        }
        return isSametree(s,t)
            || isSubtree(s->left,t)//dfs
            || isSubtree(s->right,t);     
    }
```
3.方法二
