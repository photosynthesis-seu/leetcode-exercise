# 本附录包含题目：
```
面试题08.11.硬币（动态规划/背包问题）面试题51 数组中的逆序对（归并排序） No.322零钱兑换（典型动态规划）
```
## 面试题08.11.硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## No.322 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析
+ [见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
+ 一种带备忘录的自上而下的实现（递归）

**注意怎么实现带备忘录 -> 使用带返回参数的递归**
```
class Solution {
    vector<int>count;
    int dp(vector<int>& coins, int rem) {
        if (rem < 0) return -1;
        if (rem == 0) return 0;
        if (count[rem - 1] != 0) return count[rem - 1];
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res >= 0 && res < Min) {
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount < 1) return 0;
        count.resize(amount);
        return dp(coins, amount);
    }
};
```
+ 一种自下而上的迭代算法

**从0开始，使用循环，注意和自上而下使用递归的区别**
```
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```
## 面试题51 数组中的逆序对

1.题目
```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
输入: [7,5,6,4]
输出: 5
```
2.**为了防止两个整型数相加求平均时溢出，我们通常会作如下处理：**
```
int i,j;//假设这两个数很大,且j>i
int mid = (i+j)/2;//有可能i+j溢出，不安全
int mid = i+(j-i)/2;更安全的技巧
```

2.分析

[官方题解中的视频讲解非常好！](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)
[归并算法实现详解](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/)
