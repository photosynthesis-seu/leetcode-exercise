# 本附录包含题目：
```
面试题08.11.硬币（动态规划/二维数组背包问题）面试题51 数组中的逆序对（归并排序）
面试题56-I 数组中数字出现的次数（位运算与运算符优先级）
No.3 无重复字符的最长子串（双指针、滑窗算法，动态规划，unordered_set）
No.30 串联所有单词的子串（滑窗算法，unordered_map,比较复杂）
No.35 搜索插入位置（带特判的二分查找）
No.39 组合总数（需要列举完全背包问题每种情况/面试题08.11.硬币的细化、回溯算法+剪枝）
No.40 组合总和（回溯算法+巧妙的剪枝）
No.46 全排列（递归+回溯算法+DFS）No.61 旋转链表(双指针) No.75 颜色分类 
No.124 二叉树中的最大路径和（dfs,带返回的递归问题）
No.125 验证回文串（各种内置函数：isdigt/islower/isupper）
No.172 阶乘后的零（数学技巧、腾讯面试题）
No.202 快乐数（数学技巧，unordered_set的使用,双指针的快慢指针算法）
No.225 用队列实现栈 No.232 用栈实现队列(注意循环的判断条件，如果修改栈，就不要用栈的大小判断，很关键！)
No.315 计算右侧小于当前元素的个数(归并算法+vector<pair<int,int>>索引容器) No.322 零钱兑换（典型动态规划）
No.793 阶乘函数后K个零（二分查找，腾讯面试题变种）
NO.992 排序数组（各种排序算法！）
No.1095 山脉数组中查找目标值（二分查找）

```
二分查找的一些题目（未做）
```
No.33/No.81 搜索旋转排序数组 No.153/154 搜搜旋转数组中的最小值 No.69 平方根 No.287寻找重复数
No.875 爱吃香蕉的珂珂 No.1300 转变数组后最接近目标值的数组和 No.410 分割数组的最大值
```
滑动窗口的一些题目（未做）
```
No.3 无重复字符的最长子串 No.30 串联所有单词的子串NO.76 最小覆盖子串 No.159 至多包含两个不同字符的最长子串
No.209 长度最小的子数组 No.239 滑动窗口最大值
No.340 至多包含 K 个不同字符的最长子串 No.567 字符串的排列
No.632 最小区间 No.727 最小窗口子序列
```

# 二分查找的模板

[二分查找详细解读的文章](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)
+ 只要看到 left = mid 的时候，就需要调整成为上取整mid = left + (right-left+1)/2。无条件写上 while (left < right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们的值相等。
+ 向左取值的方法
```C++
int main(vector<int>& nums, int target){
int len = nums.size();
        if (len == 0) {
            return 0;
        }
int left = 0;
// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是len。
int right = len;
int res = BinarySearch(nums,target,left,right);
return res;
}
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left)/2 ;// 向左取值
            if (check(mid) < target) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置。
                left = mid + 1;
            } else {
	    	// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
                right = mid;
            }
        }
        return left;
    }
```
+ 向右取值的方法
```C++
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left+1)/2 ;// 向右取值，这里要+1，防止死循环
            if (check(mid)) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
	    	// 只有看到 left = mid 的时候，才需要调整成为上取整，记住这一点即可
                left = mid;
            }
        }
        return left;
    }
```
## 硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

[注意区分排列数与组合数，两者情况不同](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```C++
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析
+ [见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
+ 一种带备忘录的自上而下的实现（递归）

**注意怎么实现带备忘录 -> 使用带返回参数的递归**
```C++
class Solution {
    vector<int>count;
    int dp(vector<int>& coins, int rem) {
        if (rem < 0) return -1;
        if (rem == 0) return 0;
        if (count[rem - 1] != 0) return count[rem - 1];
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res >= 0 && res < Min) {
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount < 1) return 0;
        count.resize(amount);
        return dp(coins, amount);
    }
};
```
+ 一种自下而上的迭代算法

**从0开始，使用循环，注意和自上而下使用递归的区别**
```C++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```
## 数组中的逆序对

1.题目
```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
输入: [7,5,6,4]
输出: 5
```
2.**为了防止两个整型数相加求平均时溢出，我们通常会作如下处理：**
```C++
int i,j;//假设这两个数很大,且j>i
int mid = (i+j)/2;//有可能i+j溢出，不安全
int mid = i+(j-i)/2;更安全的技巧
```

2.分析
+ 计算逆序数发生在归并排序的过程中，利用了「排序」以后数组的有序性。
+ 利用「归并排序」计算逆序对，是非常经典的做法；
  - 关键在于「合并两个有序数组」的步骤，利用数组的部分有序性，一下子计算出一个数之前或者之后元素的逆序的个数；
  - 前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数；
  - 「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；
  - 在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。
思想是「分治算法」，所有的「逆序对」来源于 3 个部分：
    - 左边区间的逆序对；
    - 右边区间的逆序对；
    - 横跨两个区间的逆序对。
  - 下面提供两种写法：
1、在第 2 个子区间元素归并回去的时候，计算逆序对的个数；
2、在第 1 个子区间元素归并回去的时候，计算逆序对的个数。
+ 实现
```C++
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }//相当于归并排序时已经拆分到了单个元素，这时直接返回0.

        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);//在归并两个有序数组前，首先将这两个数组的逆序对数目进行归并。
        int i = l, j = mid + 1, pos = l;//归并排序的下标处理
        while (i <= mid && j <= r) {//开始对两个有序数组进行归并排序
            if (nums[i] <= nums[j]) {
                tmp[pos] = nums[i];//tmp[]存放归并两个序列后的结果
                ++i;
                inv_count += (j - (mid + 1));//在第 1 个子区间元素归并回去的时候，计算逆序对的个数
            }
            else {
                tmp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {//如果第2个子区间元素耗尽，第1个子区间还有元素，则全部拷贝入tmp
            tmp[pos++] = nums[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {//第1个耗尽，第2个子区间还有元素
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);//将每一次归并排序结果拷贝到nums中。
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};
```
[官方题解中的视频讲解非常好！](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)

[归并算法实现详解](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/)

## 颜色分类

（荷兰旗问题）

1.题目
```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
2.快速排序

[详细的解读文章](https://blog.csdn.net/qq_28584889/article/details/88136498)
+ 快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：
  - 1、从数列中取出一个数作为基准数（枢轴，pivot）。 
  - 2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。
  - 3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。
+ 实现
```C++
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```


3.分析
+ 算法
  - 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.
  - 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.
  - 初始化当前考虑的元素序号 ：curr = 0.
  - While curr <= p2 :
    - 若 nums[curr] = 0 ：交换第 curr个和第 p0 个元素，并将两个指针都向右移。
    - 若 nums[curr] = 2 ：交换第 curr个和第 p2 个元素，并将p2指针左移 。
    - 若 nums[curr] = 1 ：将指针curr右移。
+ 注意，curr 左边全都是0/1的有序序列！
  - curr位置是0时，与左边的0位置交换，因为保证curr左边全是0/1, 所以交换过来的必然是0/1，状态维持住了；
  - curr位置是2时，交换后，curr不能移动，因为一移动，没法保证交换过来的是0/1；所以这里不移动；这时状态也维持住了
  - 只要我们保证curr左边的都是0,1，才移动，那么0都被放到左边，2都被放到右边，中间自然是1了。
+ 实现
```C++
void sortColors(vector<int>& nums) {
    // 对于所有 idx < p0 : nums[idx < p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > p2 : nums[idx > p2] = 2
    int p2 = nums.size() - 1;
    while (curr <= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
```
## 全排列

1.题目
```
给定一个 没有重复 数字的序列，返回其所有可能的全排列
```
2.分析

**回溯算法的注意事项：其实就是带撤销的递归算法（使用DFS思想）**
+ 使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；
+ 因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；
+ 深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈。
+ 深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。

3.vector中find函数的使用

需要使用迭代器。
```C++
vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
```
4.实现(**注意emplace_back()和find()的使用**)
```C++
class Solution {
public:
    vector<vector<int>> res;
    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(vector<int>& nums, vector<int>& track){
        // 所有数都填完了
        if (track.size() == nums.size()) {
            res.emplace_back(track);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
            track.emplace_back(nums[i]);
            backtrack(nums,track);
            track.pop_back();  
        }
    }
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    vector<vector<int>> permute(vector<int>& nums) {
        if (nums.size() == 0) return {};
	    if (nums.size() == 1) return { {nums[0]} };
        vector<int> track;
        backtrack(nums,track);
        return res;
    }
};
```
5.带备忘录的实现方法
```C++
vector<vector<int> > result;
void func(vector<int> &nums,vector<int> &current, vector<bool>&nums1)
{
	if (current.size() == nums1.size())
		result.push_back(current);
	else
	{
		for (int i = 0; i < nums.size(); i++)
		{
			if (nums1[i])
			{
				current.push_back(nums[i]);
				nums1[i] = false;
				func(nums, current, nums1);
				nums1[i] = true;
				current.pop_back();
			}
		}
	}
}
vector<vector<int>> permute(vector<int>& nums) {
	if (nums.size() == 0)
		return {};
	else if (nums.size() == 1)
		return { {nums[0]} };
	else
	{
		vector<bool> nums1(nums.size(),true);
		vector<int> current;
		func(nums, current, nums1);
		return result;
	}
}
};
```

## 计算右侧小于当前元素的个数

1.题目
```
给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入: [5,2,6,1]
输出: [2,1,1,0] 
```
2.分析
+ 使用归并排序。
  - **本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们可以在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。**
  - 同理，也可以在后有序数组出列时计算。
+ 我们借助计算 “逆序数” 的思路完成本题，关键在于这里我们只能在 “前有序数组” 出列的时候计算逆序数；
如果题目让我们计算 “nums[i] 左侧小于 nums[i] 的元素的数量” 可以在 “后有序数组” 出列的时候计算逆序数；
+ 实现
```C++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int>count;//保存结果
        vector<pair<int,int> > num;//关联每个数和它的序号
        for(int i =0;i<nums.size();++i)
        {
            count.push_back(0);
            num.push_back(make_pair(nums[i],i));//保存每个数和它在原数组中的序号，以免在排序过程中打乱顺序
        }
        merge_sort(num,count);
        return count;
    }
    
    //归并排序
    void merge_sort(vector<pair<int,int> >& vec, vector<int>& count)
    {
        if(vec.size()<2)
            return;
        
        int mid = vec.size()/2;
        vector<pair<int,int> > sub_vec1;
        vector<pair<int,int> > sub_vec2;
        for(int i =0;i<mid;++i)
            sub_vec1.push_back(vec[i]);
        for(int i =mid;i< vec.size();++i)
            sub_vec2.push_back(vec[i]);
        
        merge_sort(sub_vec1,count);
        merge_sort(sub_vec2,count);
        vec.clear();
        merge(sub_vec1,sub_vec2,vec,count);
    }
    
    //合并两数组
    void merge(vector<pair<int,int> >& sub_vec1,vector<pair<int,int> >& sub_vec2, vector<pair<int,int> >& vec,      vector<int>& count)
    {
        int i =0;
        int j =0;
        while(i < sub_vec1.size() && j < sub_vec2.size())
        {
            if(sub_vec1[i].first <= sub_vec2[j].first )
            {
                vec.push_back(sub_vec1[i]);
                count[sub_vec1[i].second] += j;//这句话和下面注释的地方就是这道题和归并排序的主要不同之处
                i++;
            }else{
                vec.push_back(sub_vec2[j]);
                j++;
            }
        }
    }
};
```
## No.125 验证回文串

1.题目
```
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
输入: "A man, a plan, a canal: Panama"
输出: true
```
2.**C++的几个内置函数**
```
islower(char c) 是否为小写字母
isuppper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小
```
3.实现
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        string tmp;
        for (auto c : s) {
            if (islower(c) || isdigit(c))  tmp += c;
            else if (isupper(c)) tmp += (c + 32);
        }
        int i = 0, j = tmp.size() - 1;
        while (i < j) {
            if (tmp[i] != tmp[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};
```
## No.61 旋转链表

1.题目
```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
```
2.分析
![image](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/images/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.png)

3.实现
```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n=0;
        for(auto p=head;p;p=p->next) n++;
        k%=n;
        auto first=head,second=head;
        while(k--){
            first=first->next;
        }
        while(first->next){
            first=first->next;
            second=second->next;
        }
        first->next=head;
        head=second->next;
        second->next=NULL;
        return head;
    }
};
``` 
## No.172 阶乘后的的零
1.题目
```
给定一个整数 n，返回 n! 结果尾数中零的数量。
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
2.分析
+ **对n一直迭代除以5就相当于求n！中5的个数了！！！**
+ 首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。
末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
+ 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...
+ 实现
```C++
    int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}

```
## 阶乘函数后K个零

（**二分查找**）

1.题目
```
f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * ... * x，且0! = 1）
例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。
示例 1:
输入:K = 0
输出:5
解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。
```
2.分析
+ 第一个需要注意的地方，二分法查找时需要注意求最大值最小值的边界处理！
  - 这种求等于某个值的**最左边界**的二分查找需要将**等于号放到大于等于的一边**num = l+(r-l)/2;countzero(num)<K；
  - 这种求某个值的**最右边界**的二分查找需要将**等于号放到小于等于的一边**num = l+(r-l+1)/2;countzero(num)<=K;
    - **一定要注意**如果这个(r-l+1)是为了在只剩两个数时，它们中间的数是右边的数。如果不写，根据判断条件（若l=0,r=1），num一直为0，那就一直循环出不来了！
```C++
 long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;//为了在只剩两个数时，它们中间的数是右边的数。
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }

```
+整体实现
```C++
class Solution {
public:
    const long long MAX_N = 1e15;
    long long countzero(long long num){
        long long res=0;
        while(num){
            res += num/5;
            num /= 5;
        }
        return res;
    }
    long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }
    int preimageSizeFZF(int K) {
        long long left = bisearchLeft(K);
        long long right = bisearchRight(K);
        return (right-left+1);
    }
};
```
## 数组中数字出现的次数

1.题目
```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```
2.运算符优先级的问题

(make_part&sum) == 0，**这里的括号不能少，因为==的优先级大于&**。
```C++
9	==  !=	等于/不等于
10	&	按位与
11	^	按位异或
12	|	按位或
```

3.分析
+ 考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。
+ 那么这一方法如何扩展到找出两个出现一次的数字。如果我们可以把所有数字分成两组，使得：
  - 两个只出现一次的数字在不同的组中；
  - 相同的数字会被分到相同的组中。
那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。
+ 实现：
```C++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int sum = 0;//求全部数组异或的结果
        for(int n:nums){//由于交换律以及异或的性质，最终结果是两个只出现一次的数字的异或的结果。
            sum ^= n;
        }
        int make_part = 1;//寻找一位作为分组时的比较位，这一位应当在异或结果sum中是1，只有这样
        //才可以让两个只出现一次的数字分在不同组。
        while((make_part&sum) == 0){//根据运算符优先级，一定要加括号
            make_part = make_part<<1;
        }
        int a=0,b=0;
        for(int n:nums){//根据比较位，将数组分为两组
            if(make_part&n){//这里不可以写为make_part&n==1!
                a ^= n;
            }
            else{
                b ^= n;
            }
        }
        return (vector<int>{a,b});
    }
};
```
## 二叉树中的最大路径和

1.题目
```
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
2.分析
+ 本题目涉及**带参数的递归调用（DFS）**
+ 递归思想直接看代码
```C++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL) return 0;
        int res = INT_MIN;//现将值设为允许的最小值（万一树节点里面全是负的）。
        dfs(root,res);//直接调用递归函数，只需要确定res，不需要使用返回值。
        return res;
    }
    int dfs(TreeNode* root,int& res){
        if(root == NULL){//DFS遍历到最底层时返回
            return 0;
        }
        int left = max(0,dfs(root->left,res));//确定当前访问节点的左子树的最大路径和
        //注意要和0比较，因为如果小于0我们可以不选择这一条路径，也就是左子树路径为0.
        int right = max(0,dfs(root->right,res));//确定当前访问节点的右子树的最大路径和
        res = max(res,root->val+right+left);//更新最大路径和，因为是当前节点的最大路径和，一定要包括当前节点
        return root->val+max(right,left);//返回时要因为时返回一条路径，
        //所以只能是当前节点和左/右子树选一条路径和大的返回
    }
};
```
## 山脉数组中查找目标值

1.题目
```
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length >= 3
其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
```
2.分析
+ 自然地，求解这道题可以分为 3 步：
  - 第 1 步：先找到山顶元素 mountaintop 所在的索引。
  - 第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；
  - 第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。
+ 注意： 具体编码实现的时候，每一步写一个辅助方法就可以了。这 3 个辅助方法都是二分查找法。
+ 具体实现：
```C++
/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *   public:
 *     int get(int index);
 *     int length();
 * };
 */

class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int len = mountainArr.length();
	//先寻找山顶元素的索引
        int peak = FindMountainPeak(mountainArr,0,len-1);
        int res;
	//在前面升序的数组中找target，如果存在，就返回它的索引.
        res = SearchForwardArray(target,mountainArr,0,peak);
        if(res != -1){
            return res;
        }
	//如果之前的升序数组中无target，则继续查找后面的降序数组，如果存在就返回索引，否则返回-1.
        return SearchReverseArray(target,mountainArr,peak,len-1);
    }
    //查找山顶元素的索引(关键在于比较mid和mid+1处元素值的大小)
    int FindMountainPeak(MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<mountainArr.get(mid+1)){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
    //在前面升序的数组中找target以及其索引，使用向左取值
    int SearchForwardArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
    //查找后面的降序数组的target以及其索引，也是使用向左取值
     int SearchReverseArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)>target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
};
```
## 搜索插入位置

1.题目
```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
输入: [1,3,5,6], 5
输出: 2
```
2.实现

**关注特例判断**
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0){
            return 0;
        }
        // 特判
        if (nums[len - 1] < target) {
            return len;
        }
        int res;
        res = BinarySearch(nums,target,0,len-1);
        return res;

    }
    int BinarySearch(vector<int>& nums,int target,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(nums[mid]<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
};
```
## 快乐数

1.题目
```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
2.注意unordered_set的使用
```C++
unordered_set<int> res;
while(n != 1 && res.find(n) == res.end()){
```
3.分析

+根据我们的探索，我们猜测会有以下三种可能。
  - 最终会得到 1。
  - 最终会进入循环。
  - 值会越来越大，最后接近无穷大。
+ 对于 3 位数的数字，最大是999，它做各位平方和运算后为243.因此它不可能大于 243。**这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止**。所以我们知道，最坏的情况下，算法可能会在 2243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。**但它不会无限期地进行下去，所以我们排除第三种选择**。
+ 因此，可以使用 哈希Set 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。如果它不在 HashSet 中，我们应该添加它。如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。

4.实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> res;
        while(n != 1 && res.find(n) == res.end()){
        res.insert(n);
        n = SquareSum(n);
        }
        if(n==1){
            return true;
        }
        else{
            return false;
        }
    }
};
```
5.快慢指针算法(**双指针思想！**)

+ 通过反复调用 SquareSum(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 SquareSum(n) 函数获得。意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。
+ 我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 SquareSum(n) 函数的嵌套调用）。
  - 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
  - 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。
+ 实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        int SlowRunner = n;
        int FastRunner = SquareSum(n);
        while(FastRunner != 1 && FastRunner != SlowRunner){
        SlowRunner = SquareSum(SlowRunner);
        FastRunner = SquareSum(SquareSum(FastRunner));
        }
        return FastRunner == 1; 
    }
};
```
## 排序数组

1.题目
```
给你一个整数数组 nums，请你将该数组升序排列。
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```
2.分析
+ 最简单的实现：调用sort函数
```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==0){
            return {};
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```
## 用队列实现栈

1.题目
```
使用队列实现栈的下列操作：
push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
```
2.分析
+ 维护队列使其队头对应栈的栈顶，队尾对应栈的栈底。则需要在每次在队列尾部加入元素之后将原本就有的res.size() - 1个元素从头取出放回尾部以使队头对应栈顶，队尾对应栈底。
+ 实现
```C++
 queue<int> res;
    /** Initialize your data structure here. */
    MyStack() = default;   
    /** Push element x onto stack. */
    void push(int x) {
        res.push(x);
        for(int i=0;i<res.size()-1;i++){
            res.push(res.front());
            res.pop();
        }
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = res.front();
        res.pop();
        return tmp;
    }
    /** Get the top element. */
    int top() {
        return res.front();
    }  
    /** Returns whether the stack is empty. */
    bool empty() {
        return res.empty();
    }
```
## 用栈实现队列

1.题目
```
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```
2.分析
+ 用两个栈实现！**一定要注意在出栈时栈的大小不能作循环条件！需要使用栈是否为空作为判断依据**
```c++
stack<int> res;
stack<int> temp;
// for(int i=0;i<res.size();i++){
//     temp.push(res.top());
//     res.pop();
// }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
 while(!res.empty()){
     temp.push(res.top());
     res.pop();
 }
```
+ 实现
```c++
stack<int> res;
    /** Initialize your data structure here. */
    MyQueue() = default;
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stack<int> temp;
        // for(int i=0;i<res.size();i++){
        //     temp.push(res.top());
        //     res.pop();
        // }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
        while(!res.empty()){
            temp.push(res.top());
            res.pop();
        }
        res.push(x);
    //     for(int j=0;j<temp.size();j++){
    //         res.push(temp.top());
    //         temp.pop();
    //     }
        while(!temp.empty()){
            res.push(temp.top());
            temp.pop();
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        int tmp = res.top();
        res.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        return res.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return res.empty();
    }
```
## 无重复字符的最长子串

1. 题目
```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
2.分析
+ 双指针、滑窗优化算法：
  - 创建一个左指针和一个右指针均指向s[0]，左指针先不动，移动右指针并计算子串长度；当出现重复字符时，向右移动左指针直至没有重复字符。子串存储在unordered_set中。
  - 部分实现
  ```C++
  for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
  ```
  - 这个while是滑窗（双指针）算法的精髓，在hashset中一直存在右指针指向的值时，一直将左指针向右移动，并删除hashset中左指针对应的值，这样做是合理的，不影响最长子串的确定。
+ 整体实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.length();
        if(len == 0) return 0;
        unordered_set<char> uset;//存储不包含重复字符的子串
        int res = 0;
        int left = 0;//滑窗中的左指针
        for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
        return res;
    }
};
```
3.动态规划算法（麻烦一些）
+ dp[i]表示以第i个字符结尾的无重复字符子串的长度。比如 abcbc :
```C++
dp[0] = 1;  "a"
dp[1] = 2;  "ab"
dp[2] = 3;  "abc"
dp[3] = 2;  "cb"
dp[4] = 2;  "bc"
```
+ 初始值：对于第一个字符，dp[0] = 1
+ 状态转移：对于第i个字符，如果在dp[i-1]所代表的子串中出现，那么从所出现的位置j的下一个位置到i，构成了以i结尾的不重复子串。即dp[i] = i-j;
如果第i个字符不在前面的dp[i-1]子串中出现，那么i-1子串加上i字符构成了i子串，因此 dp[i] = dp[i-1]+1。那么需要担心j位置后又出现了字符i吗？不需要，因为前面的子串本身就是不重复的，不可能存在两个字符i。
+ 最大值： 返回 max(dp[i])。
+ 空间优化：由于只需要知道前一个子串的长度，因此仅需记录 lastLen。
+ 实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int size = (int)s.size();
        if(size==0){
            return 0;
        } 
        int lastLen = 1;
        int max = 1;
        int curLen = 0;
        for(int i=1; i<size; ++i){
            curLen = 0;
            for(int j=i-lastLen; j<=i-1; ++j){
                if(s[j]==s[i]){
                    curLen = i-j;
                    break;
                }
            }
            if(curLen==0){
                curLen = lastLen + 1;
            }
            
            if(curLen>max){
                max = curLen;
            }

            lastLen = curLen;
        }
        return max;
    }
};
```
## 串联所有单词的子串

1.题目
```

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```
2.一些技巧

+ substr()的使用：两个参数分别为字符串中子串的起始和终止位置。
```C++
 string temp_str = s.substr(j,word_size);
```
+ unordered_map键的赋值语句:
```C++
for(auto word:words){
       m1[word]++;
   } 
```


3.分析

+ 用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（**因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他**）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。
  - 因为单词的长度 len 是固定的，所以可以将一个单词看成一个单元
  - 对单词使用滑动窗口，单元间的步长就是 len
  - 在 0 - len 的范围内，每一个都作为滑动窗口的起点，滑动 len 次，即可覆盖所有字符串的各种组合
+ 实现
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        if(words.size() == 0)//判断words为空,因为下面用到了words[0]
            return res;
        
        int word_size = words[0].size();
        int word_num = words.size();
        
        unordered_map<string,int> m1;//构造hashmap
        for(int i=0;i<word_num;i++){
            m1[words[i]]++;
        }
        //注意也可以用auto修饰符
        // for(auto word:words){
        //     m1[word]++;
        // }    
        unordered_map<string,int> m2;//统计滑窗中的单词
        for(int i=0; (i + word_size * word_num) <= s.size() ; i++){//截取的s符合题意
            int j = 0;
            for(j=i;j < (i + word_size * word_num) ; j=j+word_size){//分段判断
                string temp_str = s.substr(j,word_size);
                if(m1[temp_str] == 0){//m1中没有截取的串，直接跳出
                    break;
                }else{
                    m2[temp_str]++;
                    if(m1[temp_str] < m2[temp_str])//滑窗中单词出现次数超过了m1，也跳出
                        break;
                }
            }
            
            if(j == (i + word_size * word_num))//每一段都符合，则加入答案
                ret.push_back(i);
            
            m2.clear();//清空m2,开始下一个滑窗
        }
        return res;
    }
};

```
## 组合总数

1.题目
```

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```
2.分析

[这篇解答很棒](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)
+ 还是那个回溯算法框架
```C++
void backtrack(路径，选择列表){
    if(满足结束条件){
        result.add(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}
```
+ 以 target 为根结点，每一个分支做减法；
  - 减到 0 或者负数的时候，到了叶子结点；
  - 减到 0 的时候结算，这里 “结算” 的意思是添加到结果集；
  - 从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。
+ **剪枝去重复**
  - 在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点以本层减去的数作为搜索起点开始搜索；
  - 在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;// 从根结点到任意结点的选择路径
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(0,candidates,target);
        return res;
    }

    void dfs(int start, vector<int>& candidates, int target ){
        if(target == 0){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size();i++){
            //因为candidates排序了，当前的值都比target大，之后的一定也更大，所以直接返回
            if(target - candidates[i] < 0) return;
            path.push_back(candidates[i]);//做选择
            //注意，剪枝的核心在于起点搜索下标为i,根据深度优先树，比i小的下标的值，之前都已经深度遍历多了
            dfs(i,candidates,target-candidates[i]);
            path.pop_back();//撤销选择
        }
    }
};
```
## 组合总和

1.题目
```

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
2.分析
+ 依然是回溯算法+剪枝，注意和NO.39比较
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        if(candidates.size()==0) return {};
        dfs(candidates,target,0);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start){
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i=start;i<candidates.size();i++){
            if(target-candidates[i]<0){
                return;
            } 
            if(i>start&&candidates[i] == candidates[i-1]) continue;//仔细思考，关键的剪枝判断！
            path.push_back(candidates[i]);
            dfs(candidates,target-candidates[i],i+1);
            path.pop_back();
        }
    }
};
```
