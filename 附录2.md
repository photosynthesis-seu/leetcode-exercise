# 本附录包含题目：
```
面试题08.11.硬币（动态规划/二维数组背包问题）面试题51 数组中的逆序对（归并排序,copy函数，涉及从标准输入设备读取信息！）
面试题56-I 数组中数字出现的次数（位运算与运算符优先级）
面试题57 - II. 和为s的连续正数序列（滑动窗口算法）
面试题 01.06. 字符串压缩(遍历算法、字符串相加、to_string函数实现整数转字符串、自己实现整数转字符串)
No.3 无重复字符的最长子串（双指针、滑窗算法，动态规划，unordered_set）
No.25 k个一组翻转链表（难：两个全局指针，两个局部指针、反转链表）
No.30 串联所有单词的子串（滑窗算法，unordered_map,比较复杂）
No.35 搜索插入位置（带特判的二分查找）
No.39 组合总数（需要列举完全背包问题每种情况/面试题08.11.硬币的细化、回溯算法+剪枝）
No.40 组合总和（回溯算法+巧妙的剪枝）
No.45 跳跃游戏II(贪心算法！自己的递归会超时)
No.46 全排列（递归+回溯算法+DFS）
No.50 Pow(x,n)(经典的二分法降低计算复杂度，还有经典的x^n = exp(n*log(abs(x)));)
No.61 旋转链表(双指针)
No.69 x的平方根（二分查找、牛顿迭代算法）
No.75 颜色分类 
No.76 最小覆盖子串（比较难的滑动窗口算法！）
No.98 验证二叉搜索树（递归helper(root, ower,upper)，中序遍历 ）
No.102 二叉树的层序遍历（BFS、vector初始化的新方法）
No.124 二叉树中的最大路径和（dfs,带返回的递归问题）
No.125 验证回文串（各种内置函数：isdigt/islower/isupper）
No.136 只出现一次的数字(异或算法，类似面试题56-I 数组中数字出现的次数)
No.146 LRU缓存机制（哈希表，双向链表，自定义双向链表添加头结点、移动至头结点等等，带自定义结构体-双向链表的Unordered_map）
No.152 乘积最大子数组（动态规划、同时使用两个一维dp数组）
No.155 最小栈（使用栈容器的辅助栈方法、使用链表的方法）
No.172 阶乘后的零（数学技巧、腾讯面试题）
No.198 打家劫舍（经典的动态规划类型问题，有详细教程！）
No.202 快乐数（数学技巧，unordered_set的使用,双指针的快慢指针算法）
No.210 课程表II(全新的知识！拓扑排序和有向图、BFS(入度)、DFS)
No.221 最大正方形（典型的动态规划，需要关注暴力解法）
No.225 用队列实现栈 No.232 用栈实现队列(注意循环的判断条件，如果修改栈，就不要用栈的大小判断，很关键！)
No.236 二叉树的最近公共祖先（递归的后序遍历算法、哈希表存储父节点、以及一种很朴素容易想到但是个别用例超时的算法！）
No.287 寻找重复数（类似剑指offer3、注意空间要求O(1),使用二分查找、注意此时用数字而不是下标二分、满足特殊情况用时间换空间）
No.315 计算右侧小于当前元素的个数(归并算法+vector<pair<int,int>>索引容器) 
No.322 零钱兑换（典型动态规划）
No.365 水壶问题（BFS/DFS、数学问题、lambda表达式、unordered_set重载hash函数）
No.394 字符串解码（辅助数字栈、字符串栈，腾讯面试题目，两个栈之间巧妙地协作，编译原理？）
No.543 二叉树的直径（典型的dfs，算是后序遍历，关注怎么选择返回二叉树左右子树的路径）
No.560 和为k的子数组（双指针思想，巧妙的前缀和，哈希表unordered_map的应用）
No.572 另一个树的子树（典型的dfs+递归（考虑前、中序遍历问题）、KMP字符串匹配算法）
No.680 验证回文字符串II(双指针、贪心算法，暴力reverse会超时)
No.793 阶乘函数后K个零（二分查找，腾讯面试题变种）
No.820 单词的压缩编码（字典树，unorded_set,unordered_map）
No.836 矩形重叠（IOU，一维化投影！）
No.945 使数组唯一的最小增量(很有思维性的一题，sort排序、计数排序、线性探测+路径压缩+递归)
No.974 和可被K整除的子数组(使用哈希表的前缀和、类似动态规划、unordered_map)
No.983 最低票价（从后向前的动态规划，unordered_set，正确初始化类成员变量）
No.992 排序数组（各种排序算法！）
No.994 腐烂的橘子（典型题目！两种多源BFS的算法（两种算法的实现都很有技巧且很多细节不同，都要会）、按位取反、if的执行条件、带点动态规划那味）
No.1071 字符串的最大公因子(枚举、辗转相除，c++自带的求最大公约数的函数__gcd())
No.1095 山脉数组中查找目标值（二分查找）
No.1371 每个元音包含偶数次的最长子字符串(前缀和、压缩字符，使用位运算实现、~位运算符的使用)

```
二分查找的一些题目（未做）
```
No.33/No.81 搜索旋转排序数组 No.153/154 搜搜旋转数组中的最小值 No.69 平方根 No.287寻找重复数
No.875 爱吃香蕉的珂珂 No.1300 转变数组后最接近目标值的数组和 No.410 分割数组的最大值
```
滑动窗口的一些题目（未做）
```
No.3 无重复字符的最长子串 No.30 串联所有单词的子串NO.76 最小覆盖子串 No.159 至多包含两个不同字符的最长子串
No.209 长度最小的子数组 No.239 滑动窗口最大值
No.340 至多包含 K 个不同字符的最长子串 No.567 字符串的排列
No.632 最小区间 No.727 最小窗口子序列
```

# 二分查找的模板

[二分查找详细解读的文章](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)
+ 只要看到 left = mid 的时候，就需要调整成为上取整mid = left + (right-left+1)/2。无条件写上 while (left < right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们的值相等。
+ 向左取值的方法
```C++
int main(vector<int>& nums, int target){
int len = nums.size();
        if (len == 0) {
            return 0;
        }
int left = 0;
// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是len。
int right = len;
int res = BinarySearch(nums,target,left,right);
return res;
}
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left)/2 ;// 向左取值
            if (check(mid) < target) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置。
                left = mid + 1;
            } else {
	    	// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
                right = mid;
            }
        }
        return left;
    }
```
+ 向右取值的方法
```C++
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left+1)/2 ;// 向右取值，这里要+1，防止死循环
            if (check(mid)) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
	    	// 只有看到 left = mid 的时候，才需要调整成为上取整，记住这一点即可
                left = mid;
            }
        }
        return left;
    }
```
## 硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

[注意区分排列数与组合数，两者情况不同](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```C++
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析
+ [见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
+ 一种带备忘录的自上而下的实现（递归）

**注意怎么实现带备忘录 -> 使用带返回参数的递归**
```C++
class Solution {
    vector<int>count;
    int dp(vector<int>& coins, int rem) {
        if (rem < 0) return -1;
        if (rem == 0) return 0;
        if (count[rem - 1] != 0) return count[rem - 1];
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res >= 0 && res < Min) {
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount < 1) return 0;
        count.resize(amount);
        return dp(coins, amount);
    }
};
```
+ 一种自下而上的迭代算法

**从0开始，使用循环，注意和自上而下使用递归的区别**
```C++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```
## 数组中的逆序对

1.题目
```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
输入: [7,5,6,4]
输出: 5
```
2.**为了防止两个整型数相加求平均时溢出，我们通常会作如下处理：**
```C++
int i,j;//假设这两个数很大,且j>i
int mid = (i+j)/2;//有可能i+j溢出，不安全
int mid = i+(j-i)/2;更安全的技巧
```

3.**关于copy()函数**

+ copy函数的一些用法：
  - 将数组myints中的七个元素复制到myvector容器中：
  ```C++
  copy (myints, myints+7, myvector.begin());
  ```
  - 将数组myints中的元素向左移动一位:
  ```C++
  copy(myints + 1, myints + 7, myints);
  ```
  - **从标准输入设备读入整数**直到输入的是非整型数据为止;请输入整数序列，按任意非数字键并回车结束输入;输出容器里的所有元素，元素之间用空格隔开:
  ```C++
  #include <algorithm>
  #include <vector>
  #include <iterator>
  #include <string>
  #include<iostream>
  using namespace std；
  int main () 
  {
	 typedef vector<int> IntVector;
	 typedef istream_iterator<int> IstreamItr;
	 typedef ostream_iterator<int> OstreamItr;
	 typedef back_insert_iterator< IntVector > BackInsItr;
	 IntVector myvector;
	 // 从标准输入设备读入整数
	 // 直到输入的是非整型数据为止 请输入整数序列，按任意非数字键并回车结束输入
	 cout << "Please input element：" << endl;
	 copy(IstreamItr(cin), IstreamItr(), BackInsItr(myvector));
	 //输出容器里的所有元素，元素之间用空格隔开
	 cout << "Output : " << endl;
	 copy(myvector.begin(), myvector.end(), OstreamItr(cout, " ")); 
	 cout << endl；
	 return 0;

  }
  ```
+ [copy()函数官方说明文档](https://blog.csdn.net/baidu_41560343/article/details/83095644?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2)
copy函数复制过程是左闭右开的，而且第三个参数是提供另一个有序组的头地址。

4.分析
+ 计算逆序数发生在归并排序的过程中，利用了「排序」以后数组的有序性。
+ 利用「归并排序」计算逆序对，是非常经典的做法；
  - 关键在于「合并两个有序数组」的步骤，利用数组的部分有序性，一下子计算出一个数之前或者之后元素的逆序的个数；
  - 前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数；
  - 「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；
  - 在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。
思想是「分治算法」，所有的「逆序对」来源于 3 个部分：
    - 左边区间的逆序对；
    - 右边区间的逆序对；
    - 横跨两个区间的逆序对。
  - 下面提供两种写法：
1、在第 2 个子区间元素归并回去的时候，计算逆序对的个数；
2、在第 1 个子区间元素归并回去的时候，计算逆序对的个数。
+ 实现
```C++
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }//相当于归并排序时已经拆分到了单个元素，这时直接返回0.

        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);//在归并两个有序数组前，首先将这两个数组的逆序对数目进行归并。
        int i = l, j = mid + 1, pos = l;//归并排序的下标处理
        while (i <= mid && j <= r) {//开始对两个有序数组进行归并排序
            if (nums[i] <= nums[j]) {
                tmp[pos] = nums[i];//tmp[]存放归并两个序列后的结果
                ++i;
                inv_count += (j - (mid + 1));//在第 1 个子区间元素归并回去的时候，计算逆序对的个数
            }
            else {
                tmp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {//如果第2个子区间元素耗尽，第1个子区间还有元素，则全部拷贝入tmp
            tmp[pos++] = nums[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {//第1个耗尽，第2个子区间还有元素
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);//将每一次归并排序结果拷贝到nums中。
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};
```
[官方题解中的视频讲解非常好！](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)

[归并算法实现详解](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/)

## 颜色分类

（荷兰旗问题）

1.题目
```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
2.快速排序

[详细的解读文章](https://blog.csdn.net/qq_28584889/article/details/88136498)
+ 快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：
  - 1、从数列中取出一个数作为基准数（枢轴，pivot）。 
  - 2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。
  - 3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。
+ 实现
```C++
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```


3.分析
+ 算法
  - 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.
  - 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.
  - 初始化当前考虑的元素序号 ：curr = 0.
  - While curr <= p2 :
    - 若 nums[curr] = 0 ：交换第 curr个和第 p0 个元素，并将两个指针都向右移。
    - 若 nums[curr] = 2 ：交换第 curr个和第 p2 个元素，并将p2指针左移 。
    - 若 nums[curr] = 1 ：将指针curr右移。
+ 注意，curr 左边全都是0/1的有序序列！
  - curr位置是0时，与左边的0位置交换，因为保证curr左边全是0/1, 所以交换过来的必然是0/1，状态维持住了；
  - curr位置是2时，交换后，curr不能移动，因为一移动，没法保证交换过来的是0/1；所以这里不移动；这时状态也维持住了
  - 只要我们保证curr左边的都是0,1，才移动，那么0都被放到左边，2都被放到右边，中间自然是1了。
+ 实现
```C++
void sortColors(vector<int>& nums) {
    // 对于所有 idx < p0 : nums[idx < p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > p2 : nums[idx > p2] = 2
    int p2 = nums.size() - 1;
    while (curr <= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
```
## 全排列

1.题目
```
给定一个 没有重复 数字的序列，返回其所有可能的全排列
```
2.分析

**回溯算法的注意事项：其实就是带撤销的递归算法（使用DFS思想）**
+ 使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；
+ 因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；
+ 深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈。
+ 深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。

3.vector中find函数的使用

需要使用迭代器。
```C++
vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
```
4.实现(**注意emplace_back()和find()的使用**)
```C++
class Solution {
public:
    vector<vector<int>> res;
    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(vector<int>& nums, vector<int>& track){
        // 所有数都填完了
        if (track.size() == nums.size()) {
            res.emplace_back(track);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
            track.emplace_back(nums[i]);
            backtrack(nums,track);
            track.pop_back();  
        }
    }
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    vector<vector<int>> permute(vector<int>& nums) {
        if (nums.size() == 0) return {};
	    if (nums.size() == 1) return { {nums[0]} };
        vector<int> track;
        backtrack(nums,track);
        return res;
    }
};
```
5.带备忘录的实现方法
```C++
vector<vector<int> > result;
void func(vector<int> &nums,vector<int> &current, vector<bool>&nums1)
{
	if (current.size() == nums1.size())
		result.push_back(current);
	else
	{
		for (int i = 0; i < nums.size(); i++)
		{
			if (nums1[i])
			{
				current.push_back(nums[i]);
				nums1[i] = false;
				func(nums, current, nums1);
				nums1[i] = true;
				current.pop_back();
			}
		}
	}
}
vector<vector<int>> permute(vector<int>& nums) {
	if (nums.size() == 0)
		return {};
	else if (nums.size() == 1)
		return { {nums[0]} };
	else
	{
		vector<bool> nums1(nums.size(),true);
		vector<int> current;
		func(nums, current, nums1);
		return result;
	}
}
};
```

## 计算右侧小于当前元素的个数

1.题目
```
给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入: [5,2,6,1]
输出: [2,1,1,0] 
```
2.分析
+ 使用归并排序。
  - **本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们可以在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。**
  - 同理，也可以在后有序数组出列时计算。
+ 我们借助计算 “逆序数” 的思路完成本题，关键在于这里我们只能在 “前有序数组” 出列的时候计算逆序数；
如果题目让我们计算 “nums[i] 左侧小于 nums[i] 的元素的数量” 可以在 “后有序数组” 出列的时候计算逆序数；
+ 实现
```C++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int>count;//保存结果
        vector<pair<int,int> > num;//关联每个数和它的序号
        for(int i =0;i<nums.size();++i)
        {
            count.push_back(0);
            num.push_back(make_pair(nums[i],i));//保存每个数和它在原数组中的序号，以免在排序过程中打乱顺序
        }
        merge_sort(num,count);
        return count;
    }
    
    //归并排序
    void merge_sort(vector<pair<int,int> >& vec, vector<int>& count)
    {
        if(vec.size()<2)
            return;
        
        int mid = vec.size()/2;
        vector<pair<int,int> > sub_vec1;
        vector<pair<int,int> > sub_vec2;
        for(int i =0;i<mid;++i)
            sub_vec1.push_back(vec[i]);
        for(int i =mid;i< vec.size();++i)
            sub_vec2.push_back(vec[i]);
        
        merge_sort(sub_vec1,count);
        merge_sort(sub_vec2,count);
        vec.clear();
        merge(sub_vec1,sub_vec2,vec,count);
    }
    
    //合并两数组
    void merge(vector<pair<int,int> >& sub_vec1,vector<pair<int,int> >& sub_vec2, vector<pair<int,int> >& vec,      vector<int>& count)
    {
        int i =0;
        int j =0;
        while(i < sub_vec1.size() && j < sub_vec2.size())
        {
            if(sub_vec1[i].first <= sub_vec2[j].first )
            {
                vec.push_back(sub_vec1[i]);
                count[sub_vec1[i].second] += j;//这句话和下面注释的地方就是这道题和归并排序的主要不同之处
                i++;
            }else{
                vec.push_back(sub_vec2[j]);
                j++;
            }
        }
    }
};
```
## No.125 验证回文串

1.题目
```
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
输入: "A man, a plan, a canal: Panama"
输出: true
```
2.**C++的几个内置函数**
```
islower(char c) 是否为小写字母
isuppper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小
```
3.实现
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        string tmp;
        for (auto c : s) {
            if (islower(c) || isdigit(c))  tmp += c;
            else if (isupper(c)) tmp += (c + 32);
        }
        int i = 0, j = tmp.size() - 1;
        while (i < j) {
            if (tmp[i] != tmp[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};
```
## No.61 旋转链表

1.题目
```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
```
2.分析
![image](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/images/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.png)

3.实现
```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n=0;
        for(auto p=head;p;p=p->next) n++;
        k%=n;
        auto first=head,second=head;
        while(k--){
            first=first->next;
        }
        while(first->next){
            first=first->next;
            second=second->next;
        }
        first->next=head;
        head=second->next;
        second->next=NULL;
        return head;
    }
};
``` 
## No.172 阶乘后的的零
1.题目
```
给定一个整数 n，返回 n! 结果尾数中零的数量。
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
2.分析
+ **对n一直迭代除以5就相当于求n！中5的个数了！！！**
+ 首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。
末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
+ 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...
+ 实现
```C++
    int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}

```
## 阶乘函数后K个零

（**二分查找**）

1.题目
```
f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * ... * x，且0! = 1）
例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。
示例 1:
输入:K = 0
输出:5
解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。
```
2.分析
+ 第一个需要注意的地方，二分法查找时需要注意求最大值最小值的边界处理！
  - 这种求等于某个值的**最左边界**的二分查找需要将**等于号放到大于等于的一边**num = l+(r-l)/2;countzero(num)<K；
  - 这种求某个值的**最右边界**的二分查找需要将**等于号放到小于等于的一边**num = l+(r-l+1)/2;countzero(num)<=K;
    - **一定要注意**如果这个(r-l+1)是为了在只剩两个数时，它们中间的数是右边的数。如果不写，根据判断条件（若l=0,r=1），num一直为0，那就一直循环出不来了！
```C++
 long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;//为了在只剩两个数时，它们中间的数是右边的数。
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }

```
+整体实现
```C++
class Solution {
public:
    const long long MAX_N = 1e15;
    long long countzero(long long num){
        long long res=0;
        while(num){
            res += num/5;
            num /= 5;
        }
        return res;
    }
    long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }
    int preimageSizeFZF(int K) {
        long long left = bisearchLeft(K);
        long long right = bisearchRight(K);
        return (right-left+1);
    }
};
```
## 数组中数字出现的次数

1.题目
```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```
2.运算符优先级的问题

(make_part&sum) == 0，**这里的括号不能少，因为==的优先级大于&**。
```C++
9	==  !=	等于/不等于
10	&	按位与
11	^	按位异或
12	|	按位或
```

3.分析
+ 考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。
+ 那么这一方法如何扩展到找出两个出现一次的数字。如果我们可以把所有数字分成两组，使得：
  - 两个只出现一次的数字在不同的组中；
  - 相同的数字会被分到相同的组中。
那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。
+ 实现：
```C++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int sum = 0;//求全部数组异或的结果
        for(int n:nums){//由于交换律以及异或的性质，最终结果是两个只出现一次的数字的异或的结果。
            sum ^= n;
        }
        int make_part = 1;//寻找一位作为分组时的比较位，这一位应当在异或结果sum中是1，只有这样
        //才可以让两个只出现一次的数字分在不同组。
        while((make_part&sum) == 0){//根据运算符优先级，一定要加括号
            make_part = make_part<<1;
        }
        int a=0,b=0;
        for(int n:nums){//根据比较位，将数组分为两组
            if(make_part&n){//这里不可以写为make_part&n==1!
                a ^= n;
            }
            else{
                b ^= n;
            }
        }
        return (vector<int>{a,b});
    }
};
```
## 二叉树中的最大路径和

1.题目
```
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
2.分析
+ 本题目涉及**带参数的递归调用（DFS）**
+ 递归思想直接看代码
```C++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL) return 0;
        int res = INT_MIN;//现将值设为允许的最小值（万一树节点里面全是负的）。
        dfs(root,res);//直接调用递归函数，只需要确定res，不需要使用返回值。
        return res;
    }
    int dfs(TreeNode* root,int& res){
        if(root == NULL){//DFS遍历到最底层时返回
            return 0;
        }
        int left = max(0,dfs(root->left,res));//确定当前访问节点的左子树的最大路径和
        //注意要和0比较，因为如果小于0我们可以不选择这一条路径，也就是左子树路径为0.
        int right = max(0,dfs(root->right,res));//确定当前访问节点的右子树的最大路径和
        res = max(res,root->val+right+left);//更新最大路径和，因为是当前节点的最大路径和，一定要包括当前节点
        return root->val+max(right,left);//返回时要因为时返回一条路径，
        //所以只能是当前节点和左/右子树选一条路径和大的返回
    }
};
```
## 山脉数组中查找目标值

1.题目
```
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length >= 3
其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
```
2.分析
+ 自然地，求解这道题可以分为 3 步：
  - 第 1 步：先找到山顶元素 mountaintop 所在的索引。
  - 第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；
  - 第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。
+ 注意： 具体编码实现的时候，每一步写一个辅助方法就可以了。这 3 个辅助方法都是二分查找法。
+ 具体实现：
```C++
/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *   public:
 *     int get(int index);
 *     int length();
 * };
 */

class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int len = mountainArr.length();
	//先寻找山顶元素的索引
        int peak = FindMountainPeak(mountainArr,0,len-1);
        int res;
	//在前面升序的数组中找target，如果存在，就返回它的索引.
        res = SearchForwardArray(target,mountainArr,0,peak);
        if(res != -1){
            return res;
        }
	//如果之前的升序数组中无target，则继续查找后面的降序数组，如果存在就返回索引，否则返回-1.
        return SearchReverseArray(target,mountainArr,peak,len-1);
    }
    //查找山顶元素的索引(关键在于比较mid和mid+1处元素值的大小)
    int FindMountainPeak(MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<mountainArr.get(mid+1)){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
    //在前面升序的数组中找target以及其索引，使用向左取值
    int SearchForwardArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
    //查找后面的降序数组的target以及其索引，也是使用向左取值
     int SearchReverseArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)>target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
};
```
## 搜索插入位置

1.题目
```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
输入: [1,3,5,6], 5
输出: 2
```
2.实现

**关注特例判断**
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0){
            return 0;
        }
        // 特判
        if (nums[len - 1] < target) {
            return len;
        }
        int res;
        res = BinarySearch(nums,target,0,len-1);
        return res;

    }
    int BinarySearch(vector<int>& nums,int target,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(nums[mid]<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
};
```
## 快乐数

1.题目
```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
2.注意unordered_set的使用
```C++
unordered_set<int> res;
while(n != 1 && res.find(n) == res.end()){
```
3.分析

+根据我们的探索，我们猜测会有以下三种可能。
  - 最终会得到 1。
  - 最终会进入循环。
  - 值会越来越大，最后接近无穷大。
+ 对于 3 位数的数字，最大是999，它做各位平方和运算后为243.因此它不可能大于 243。**这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止**。所以我们知道，最坏的情况下，算法可能会在 2243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。**但它不会无限期地进行下去，所以我们排除第三种选择**。
+ 因此，可以使用 哈希Set 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。如果它不在 HashSet 中，我们应该添加它。如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。

4.实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> res;
        while(n != 1 && res.find(n) == res.end()){
        res.insert(n);
        n = SquareSum(n);
        }
        if(n==1){
            return true;
        }
        else{
            return false;
        }
    }
};
```
5.快慢指针算法(**双指针思想！**)

+ 通过反复调用 SquareSum(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 SquareSum(n) 函数获得。意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。
+ 我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 SquareSum(n) 函数的嵌套调用）。
  - 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
  - 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。
+ 实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        int SlowRunner = n;
        int FastRunner = SquareSum(n);
        while(FastRunner != 1 && FastRunner != SlowRunner){
        SlowRunner = SquareSum(SlowRunner);
        FastRunner = SquareSum(SquareSum(FastRunner));
        }
        return FastRunner == 1; 
    }
};
```
## 排序数组

1.题目
```
给你一个整数数组 nums，请你将该数组升序排列。
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```
2.分析
+ 最简单的实现：调用sort函数
```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==0){
            return {};
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```
## 用队列实现栈

1.题目
```
使用队列实现栈的下列操作：
push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
```
2.分析
+ 维护队列使其队头对应栈的栈顶，队尾对应栈的栈底。则需要在每次在队列尾部加入元素之后将原本就有的res.size() - 1个元素从头取出放回尾部以使队头对应栈顶，队尾对应栈底。
+ 实现
```C++
 queue<int> res;
    /** Initialize your data structure here. */
    MyStack() = default;   
    /** Push element x onto stack. */
    void push(int x) {
        res.push(x);
        for(int i=0;i<res.size()-1;i++){
            res.push(res.front());
            res.pop();
        }
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = res.front();
        res.pop();
        return tmp;
    }
    /** Get the top element. */
    int top() {
        return res.front();
    }  
    /** Returns whether the stack is empty. */
    bool empty() {
        return res.empty();
    }
```
## 用栈实现队列

1.题目
```
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```
2.分析
+ 用两个栈实现！**一定要注意在出栈时栈的大小不能作循环条件！需要使用栈是否为空作为判断依据**
```c++
stack<int> res;
stack<int> temp;
// for(int i=0;i<res.size();i++){
//     temp.push(res.top());
//     res.pop();
// }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
 while(!res.empty()){
     temp.push(res.top());
     res.pop();
 }
```
+ 实现
```c++
stack<int> res;
    /** Initialize your data structure here. */
    MyQueue() = default;
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stack<int> temp;
        // for(int i=0;i<res.size();i++){
        //     temp.push(res.top());
        //     res.pop();
        // }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
        while(!res.empty()){
            temp.push(res.top());
            res.pop();
        }
        res.push(x);
    //     for(int j=0;j<temp.size();j++){
    //         res.push(temp.top());
    //         temp.pop();
    //     }
        while(!temp.empty()){
            res.push(temp.top());
            temp.pop();
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        int tmp = res.top();
        res.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        return res.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return res.empty();
    }
```
## 无重复字符的最长子串

1. 题目
```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
2.分析
+ 双指针、滑窗优化算法：
  - 创建一个左指针和一个右指针均指向s[0]，左指针先不动，移动右指针并计算子串长度；当出现重复字符时，向右移动左指针直至没有重复字符。子串存储在unordered_set中。
  - 部分实现
  ```C++
  for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
  ```
  - 这个while是滑窗（双指针）算法的精髓，在hashset中一直存在右指针指向的值时，一直将左指针向右移动，并删除hashset中左指针对应的值，这样做是合理的，不影响最长子串的确定。
+ 整体实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.length();
        if(len == 0) return 0;
        unordered_set<char> uset;//存储不包含重复字符的子串
        int res = 0;
        int left = 0;//滑窗中的左指针
        for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
        return res;
    }
};
```
3.动态规划算法（麻烦一些）
+ dp[i]表示以第i个字符结尾的无重复字符子串的长度。比如 abcbc :
```C++
dp[0] = 1;  "a"
dp[1] = 2;  "ab"
dp[2] = 3;  "abc"
dp[3] = 2;  "cb"
dp[4] = 2;  "bc"
```
+ 初始值：对于第一个字符，dp[0] = 1
+ 状态转移：对于第i个字符，如果在dp[i-1]所代表的子串中出现，那么从所出现的位置j的下一个位置到i，构成了以i结尾的不重复子串。即dp[i] = i-j;
如果第i个字符不在前面的dp[i-1]子串中出现，那么i-1子串加上i字符构成了i子串，因此 dp[i] = dp[i-1]+1。那么需要担心j位置后又出现了字符i吗？不需要，因为前面的子串本身就是不重复的，不可能存在两个字符i。
+ 最大值： 返回 max(dp[i])。
+ 空间优化：由于只需要知道前一个子串的长度，因此仅需记录 lastLen。
+ 实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int size = (int)s.size();
        if(size==0){
            return 0;
        } 
        int lastLen = 1;
        int max = 1;
        int curLen = 0;
        for(int i=1; i<size; ++i){
            curLen = 0;
            for(int j=i-lastLen; j<=i-1; ++j){
                if(s[j]==s[i]){
                    curLen = i-j;
                    break;
                }
            }
            if(curLen==0){
                curLen = lastLen + 1;
            }
            
            if(curLen>max){
                max = curLen;
            }

            lastLen = curLen;
        }
        return max;
    }
};
```
## 串联所有单词的子串

1.题目
```

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```
2.一些技巧

+ substr()的使用：两个参数分别为字符串中子串的起始和终止位置。
```C++
 string temp_str = s.substr(j,word_size);
```
+ unordered_map键的赋值语句:
```C++
for(auto word:words){
       m1[word]++;
   } 
```


3.分析

+ 用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（**因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他**）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。
  - 因为单词的长度 len 是固定的，所以可以将一个单词看成一个单元
  - 对单词使用滑动窗口，单元间的步长就是 len
  - 在 0 - len 的范围内，每一个都作为滑动窗口的起点，滑动 len 次，即可覆盖所有字符串的各种组合
+ 实现
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        if(words.size() == 0)//判断words为空,因为下面用到了words[0]
            return res;
        
        int word_size = words[0].size();
        int word_num = words.size();
        
        unordered_map<string,int> m1;//构造hashmap
        for(int i=0;i<word_num;i++){
            m1[words[i]]++;
        }
        //注意也可以用auto修饰符
        // for(auto word:words){
        //     m1[word]++;
        // }    
        unordered_map<string,int> m2;//统计滑窗中的单词
        for(int i=0; (i + word_size * word_num) <= s.size() ; i++){//截取的s符合题意
            int j = 0;
            for(j=i;j < (i + word_size * word_num) ; j=j+word_size){//分段判断
                string temp_str = s.substr(j,word_size);
                if(m1[temp_str] == 0){//m1中没有截取的串，直接跳出
                    break;
                }else{
                    m2[temp_str]++;
                    if(m1[temp_str] < m2[temp_str])//滑窗中单词出现次数超过了m1，也跳出
                        break;
                }
            }
            
            if(j == (i + word_size * word_num))//每一段都符合，则加入答案
                ret.push_back(i);
            
            m2.clear();//清空m2,开始下一个滑窗
        }
        return res;
    }
};

```
## 组合总数

1.题目
```

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```
2.分析

[这篇解答很棒](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)
+ 还是那个回溯算法框架
```C++
void backtrack(路径，选择列表){
    if(满足结束条件){
        result.add(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}
```
+ 以 target 为根结点，每一个分支做减法；
  - 减到 0 或者负数的时候，到了叶子结点；
  - 减到 0 的时候结算，这里 “结算” 的意思是添加到结果集；
  - 从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。
+ **剪枝去重复**
  - 在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点以本层减去的数作为搜索起点开始搜索；
  - 在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;// 从根结点到任意结点的选择路径
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(0,candidates,target);
        return res;
    }

    void dfs(int start, vector<int>& candidates, int target ){
        if(target == 0){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size();i++){
            //因为candidates排序了，当前的值都比target大，之后的一定也更大，所以直接返回
            if(target - candidates[i] < 0) return;
            path.push_back(candidates[i]);//做选择
            //注意，剪枝的核心在于起点搜索下标为i,根据深度优先树，比i小的下标的值，之前都已经深度遍历多了
            dfs(i,candidates,target-candidates[i]);
            path.pop_back();//撤销选择
        }
    }
};
```
## 组合总和

1.题目
```

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
2.分析
+ 依然是回溯算法+剪枝，注意和NO.39比较
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        if(candidates.size()==0) return {};
        dfs(candidates,target,0);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start){
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i=start;i<candidates.size();i++){
            if(target-candidates[i]<0){
                return;
            } 
            if(i>start&&candidates[i] == candidates[i-1]) continue;//仔细思考，关键的剪枝判断！
            path.push_back(candidates[i]);
            dfs(candidates,target-candidates[i],i+1);
            path.pop_back();
        }
    }
};
```
## 跳跃游戏II

**关注贪心算法！**

1.题目
```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
2.分析

+ 自己的递归算法会超时，递归条件如果也要贪心算法的话，就没必要递归了。
+ 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。
  - 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。
  - 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。
+ 实现
```C++
int jump(vector<int> &nums){
        int ans = 0;
        int start = 0;
        int end = 1;
        while (end < nums.size()){
            int maxPos = 0;
            for (int i = start; i < end; i++){
                // 能跳到最远的距离
                maxPos = max(maxPos, i + nums[i]);
            }
            start = end;      // 下一次起跳点范围开始的格子
            end = maxPos + 1; // 下一次起跳点范围结束的格子
            ans++;            // 跳跃次数
        }
        return ans;
    } 
```

## 和为s的连续正数序列

1.题目
```
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

输入：target = 9
输出：[[2,3,4],[4,5]]
```
2.分析

+ 要用滑动窗口解这道题，我们要回答两个问题：第一个问题，窗口何时扩大，何时缩小？第二个问题，滑动窗口能找到全部的解？
+ 对于第一个问题：
  - 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动。
  - 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动。
  - 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为[i,j]，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。
+ 第二个证明是显然的，因为序列是等差单增的。
+ 实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。
+ 实现：
```C++
vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int left = 1;//左指针（左边界）
        int right = 1;//右指针（右边界）
        int sum = 0;
        while(left<=target/2){//题目要求一个序列至少包含两个数，所以左滑窗到target一半即可。
            if(sum<target){
                sum += right;
                right++;
            }
            else if(sum>target){
                sum -=left;
                left++;
            }
            else{//滑窗内和为target
                vector<int> temp;
                for(int i=left;i<right;i++){
                    temp.push_back(i);
                }
                res.push_back(temp);
                sum -= left;//向右移动左指针，注意和下一句顺序不能反。
                left++;   
            }
        }
        return res;
    }
```
## 验证二叉搜索树

**关注中序遍历二叉树的实现！！，关注此题递归函数的退出条件！！**

1.题目
```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

输入:
    2
   / \
  1   3
输出: true
```
2.分析

+ 由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
+ 这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。
+ 那么根据二叉搜索树的性质，在递归调用左子树时，需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。
+ 函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。
+ 实现
```C++
 bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;//关注递归函数返回为真的判断！即遍历到底nullptr也没出错！！
        if (root -> val <= lower || root -> val >= upper) return false;
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);//关注起始时的最大最小值
    }
```
3.中序遍历方法
```C++
  //关注栈的使用
  bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) return false;
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }

```
或者
```C++
class Solution {
public :
    long pre = MIN_LONG;
    boolean isValidBST(TreeNode* root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root->left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root->val <= pre) {
            return false;
        }
        pre = root->val;
        // 访问右子树
        return isValidBST(root->right);
    }
}
```
## 最低票价

1.题目
```
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
一张为期一天的通行证售价为 costs[0] 美元；
一张为期七天的通行证售价为 costs[1] 美元；
一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```
2.**需要正确地在类中初始化vector成员变量**

+ **错误方法**
```C++
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
```
+ **正确方法**
```C++
//C++11后
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
//C++11之前
class Foo {
public:
    vector<string> name;
    vector<int> val;
    Foo() : name(5), val(5,0) {}
};
```


3.分析

+ 用 dp(i) 来表示从第 i 天开始到一年的结束，需要花的钱。考虑到一张通行证可以让我们在「接下来」的若干天进行旅行，所以**「从后往前」**倒着进行动态规划。**代码中的体现就是主函数中dp函数从dp(1)开始**
+ 对于一年中的任意一天：
  - 如果这一天不是必须出行的日期，可以贪心地选择不买。这是因为如果今天不用出行，那么也不必购买通行证，并且通行证越晚买越好。所以有 dp(i)=dp(i+1)；
  - 如果这一天是必须出行的日期，可以选择买 1，7 或 30 天的通行证。若购买了 j 天的通行证，那么接下来的 j−1 天，都不再需要购买通行证，只需要考虑第 i+j 天及以后即可。因此有： dp(i)=min{cost(j)+dp(i+j)},j∈{1,7,30}. 其中 cost(j) 表示 j 天通行证的价格;
+ 由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366 的数组（因为天数是[1,365]，而数组的下标是从 0 开始的）存储所有的动态规划结果，这样所有的 dp(i) 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。
+ 实现
```C++
unordered_set<int> travaldays;//保存旅行日期
    vector<int> memo;//类成员不能直接初始化，要在成员函数里初始化！
    vector<int> costs;//全局声明，这样dp函数就可以直接用了，不用传参costs[]。
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        memo.resize(366,-1);//记录从任意一天开始旅行的最小花费
        this->costs = costs;
        for(auto tarvelday : days){
            travaldays.insert(tarvelday);
        }
        int result = dp(1);//从后往前递归和动态规划
        return result;
    }
    int dp(int startday){
        if(startday > 365){
            return 0;
        }
        if(memo[startday] != -1){
            return memo[startday];
        }
        if(!travaldays.count(startday)){
            //注意这里是dp(startday+1)不是memo[startday+1],因为是从后往前动态规划，要先把后面动态规划的值求出来
            memo[startday] = dp(startday+1);
        }
        else{
            memo[startday] = min(dp(startday+1)+costs[0],min(dp(startday+7)+costs[1],dp(startday+30)+costs[2]));
        }
        return memo[startday];
    }
```
## 水壶问题

1.题目
```
有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。
你允许：
装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空

输入: x = 3, y = 5, z = 4
输出: True
```
2.**lambda函数与表达式**：

+ C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下：
```C++
[capture](parameters) mutable ->return-type{statement};
//例如
[](int x, int y){ return x < y ; };
[](int x, int y) -> int { int z = x + y; return z + x; };
```
+ [capture]：捕捉列表。捕捉列表总是出现在 lambda 表达式的开始处。事实上，[] 是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数。捕捉列表能够捕捉上下文中的变量供 lambda 函数使用。
```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```
+ (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号 () 一起省略。
+ mutable：mutable 修饰符。默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。
+ ->return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号 -> 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。
+ {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

3.**decltype 关键字**

+ 官方说明
```
decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto是有一些区别的。
decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，
返回该表达式的类型,而且decltype并不会对表达式进行求值。

decltype关键字用于查询表达式的类型，并不会对表达式进行求值。
decltype的作用是获得一个变量或表达式的类型。
decltype 不会执行表达式而auto会，decltype仅仅推论一下表达式的类型。
```
+ 对于decltype(e)而言，其判别结果受以下条件的影响：
  - 如果e是一个标识符或者类成员的访问表达式，则decltype(e)就是e所代表的实体的类型。如果没有这种类型或者e是一个重载函数集，那么程序是错误的；
  - 如果e是一个函数调用或者一个重载操作符调用(忽略e外面的括号)，那么decltype(e)就是该函数的返回类型；
  - 如果e不属于以上所述的情况，则假设e的类型是 T：当e是一个左值时，decltype(e)就是T&；否则(e是一个右值)，decltype(e)是T。
+ 一些例子：
```C++
#include "decltype.hpp"
#include <iostream>
#include <string>
#include <utility>
#include <iomanip>
 
//////////////////////////////////////////////
// reference: http://en.cppreference.com/w/cpp/language/decltype
struct A { double x; };
const A* a = new A{ 0 };
 
decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
 
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u); // return type depends on template parameters
 
int test_decltype1()
{
	int i = 33;
	decltype(i) j = i * 2;
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	auto f = [](int a, int b) -> int
	{
		return a * b;
	};
 
	decltype(f) g = f; // the type of a lambda function is unique and unnamed
	i = f(2, 2);
	j = g(3, 3);
 
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	return 0;
}
```
4.分析

+ 在任意一个时刻，此问题的状态可以由两个数字决定：X 壶中的水量，以及 Y 壶中的水量。在任意一个时刻，我们可以且仅可以采取以下几种操作：
  - 把 X 壶的水灌进 Y 壶，直至灌满或倒空；
  - 把 Y 壶的水灌进 X 壶，直至灌满或倒空；
  - 把 X 壶灌满；
  - 把 Y 壶灌满；
  - 把 X 壶倒空；
  - 把 Y 壶倒空。
+ 因此，本题可以使用深度优先搜索来解决。搜索中的每一步以 remain_x, remain_y 作为状态，即表示 X 壶和 Y 壶中的水量。在每一步搜索时，我们会依次尝试所有的操作，递归地搜索下去。这可能会导致我们陷入无止境的递归，因此我们还需要使用一个哈希结合（HashSet）存储所有已经搜索过的 remain_x, remain_y 状态，保证每个状态至多只被搜索一次。
+ 实现
```C++
using PII = pair<int, int>;

class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        stack<PII> stk;
        stk.emplace(0, 0);
        auto hash_function = [](const PII& o) {return hash<int>()(o.first) ^ hash<int>()(o.second);};
        unordered_set<PII, decltype(hash_function)> seen(0, hash_function);
        while (!stk.empty()) {
            if (seen.count(stk.top())) {
                stk.pop();
                continue;
            }
            seen.emplace(stk.top());
            
            auto [remain_x, remain_y] = stk.top();
            stk.pop();
            if (remain_x == z || remain_y == z || remain_x + remain_y == z) {
                return true;
            }
            // 把 X 壶灌满。
            stk.emplace(x, remain_y);
            // 把 Y 壶灌满。
            stk.emplace(remain_x, y);
            // 把 X 壶倒空。
            stk.emplace(0, remain_y);
            // 把 Y 壶倒空。
            stk.emplace(remain_x, 0);
            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stk.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));
            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stk.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));
        }
        return false;
    }
};
```
5.数学方法

+ 我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得ax+by=z
  - 而只要满足 z≤x+y，且这样的 a, ba,b 存在，那么我们的目标就是可以达成的。这是因为：
  - 若 a≥0,b≥0，那么显然可以达成目标。
  - 若 a<0，那么可以进行以下操作：
    - 往 y 壶倒水；
    - 把 y 壶的水倒入 x 壶；
    - 如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。
  - 重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。
  - 若 b<0，方法同上，x 与 y 互换。
+ 根据贝祖定理，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。
+ 实现
```C++
    bool canMeasureWater(int x, int y, int z) {
        if (x + y < z) return false;
        if (x == 0 || y == 0) return z == 0 || x + y == z;
        return z % gcd(x, y) == 0;
    }
```
## 另一个树的子树

1.题目
```
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true
```
2.方法一（dfs+递归）

+ 一个树是另一个树的子树，那么即有：
  - 要么这两个树相等
  - 要么这个树是左树的子树
  - 要么这个树是右树的子树
+ 基于dfs和递归对每一个节点进行判断，**注意dfs遍历二叉树，就是前序遍历，参考No.98/105**
+ 实现
```C++
    bool isSametree(TreeNode* s, TreeNode* t){//判断两棵树是否相等
        if(s == nullptr&&t == nullptr){
            return true;//递归的返回条件，均空自然之前全相等，所以返回真。
        }
        return s&&t
                && s->val == t->val
                && isSametree(s->left,t->left)//递归判断
                && isSametree(s->right,t->right);
    }
    bool isSubtree(TreeNode* s, TreeNode* t) {//判断t是否是s的子树
        if(s == nullptr&&t == nullptr){
            return true;
        }
        if(s == nullptr&&t != nullptr){
            return false;
        }
        return isSametree(s,t)
            || isSubtree(s->left,t)//dfs
            || isSubtree(s->right,t);     
    }
```
3.方法二

[方法介绍](https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/)
+ **一棵子树上的点在 DFS 序列（即前序遍历）中是连续的**。我们可以确定解决这个问题的方向就是：把 s 和 t 先转换成 DFS 序，然后看 t 的 DFS 序是否是 s 的 DFS 序的「子串」。

+ 存在的问题： 假设 s 由两个点组成，1 是根，2 是 1 的左孩子；t 也由两个点组成，1 是根，2 是 1 的右孩子。这样一来 s 和 t 的 DFS 序相同，可是 t 并不是 s 的某一棵子树。由此可见「s 的 DFS 序包含 t 的 DFS 序」是「t 是 s 子树」的 必要不充分条件，所以单纯这样做是不正确的。

+ 为了解决这个问题，我们可以引入两个空值 lNull 和 rNull，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样 DFS 序列就唯一对应一棵树。处理完之后，就可以通过判断 「s 的 DFS 序包含 t 的 DFS 序」来判断答案。

+ 在判断「s 的 DFS 序包含 t 的 DFS 序」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用 Rabin-Karp 算法的时候，要注意串中可能有负值。
+实现
```C++
    vector <int> sOrder, tOrder;
    int maxElement, lNull, rNull;

    void getMaxElement(TreeNode *o) {
        if (!o) return;
        maxElement = max(maxElement, o->val);
        getMaxElement(o->left);
        getMaxElement(o->right);
    }

    void getDfsOrder(TreeNode *o, vector <int> &tar) {
        if (!o) return;
        tar.push_back(o->val);
        if (o->left) getDfsOrder(o->left, tar);
        else tar.push_back(lNull);
        if (o->right) getDfsOrder(o->right, tar);
        else tar.push_back(rNull);
    }

    bool kmp() {
        int sLen = sOrder.size(), tLen = tOrder.size();
        vector <int> fail(tOrder.size(), -1);
        for (int i = 1, j = -1; i < tLen; ++i) {
            while (j != -1 && tOrder[i] != tOrder[j + 1]) j = fail[j];
            if (tOrder[i] == tOrder[j + 1]) ++j;
            fail[i] = j;
        }
        for (int i = 0, j = -1; i < sLen; ++i) {
            while (j != -1 && sOrder[i] != tOrder[j + 1]) j = fail[j];
            if (sOrder[i] == tOrder[j + 1]) ++j;
            if (j == tLen - 1) return true;
        }
        return false;
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        maxElement = INT_MIN;
        getMaxElement(s);
        getMaxElement(t);
        lNull = maxElement + 1;
        rNull = maxElement + 2;

        getDfsOrder(s, sOrder);
        getDfsOrder(t, tOrder);

        return kmp();
    }
```
## 单词的压缩编码

1.题目
```
给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。
例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。
对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。
那么成功对给定单词列表进行编码的最小字符串长度是多少呢？
输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。
```
2.substr函数用法

+ 用途：一种构造string的方法
+ 形式：s.substr(pos, n)
+ 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）
+ 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾

3.**字典树**

+ 字典树又名前缀树，Trie树，是一种存储大量字符串的树形数据结构，相比于HashMap存储，在存储单词（和语种无关，任意语言都可以）的场景上，节省了大量的内存空间。
+ 根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。
+ 用字典树去做的题目，明显特征就是需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀。 
  - **用后缀也可以的原因是因为把单词倒着插入，就可以搜后缀了**

4.方法一
+ 如果单词 X 是 Y 的后缀，那么单词 X 就不需要考虑了，因为编码 Y 的时候就同时将 X 编码了。例如，如果 words 中同时有 "me" 和 "time"，我们就可以在不改变答案的情况下不考虑 "me"。
+ 如果单词 Y 不在任何别的单词 X 的后缀中出现，那么 Y 一定是编码字符串的一部分。
+ 因此，目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。
+ 实现
```C++
    int minimumLengthEncoding(vector<string>& words) {
        unordered_set<string> good(words.begin(), words.end());
        for (const string& word: words) {
            for (int k = 1; k < word.size(); ++k) {
                good.erase(word.substr(k));
            }
        }

        int ans = 0;
        for (const string& word: good) {
            ans += word.size() + 1;
        }
        return ans;
    }
```
5.方法二
+ 去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 "time" 和 "me"，可以将 "emit" 和 "em" 插入字典树中。
+ 实现
```C++
class TrieNode{//定义一个字典树
    TrieNode* children[26];//指针的数组，每个父节点最多有26个子节点
public:
    int count;
    TrieNode() {//构造函数初始化，构造父节点和它的26个子节点
        for (int i = 0; i < 26; ++i) children[i] = NULL;
        count = 0;
    }
    //将字母转化为数字，如果是新字母，就创建一个新的子树。并加1表示这个节点不是最后一个节点，也就是叶子结点。
    TrieNode* get(char c) {
        if (children[c - 'a'] == NULL) {
            children[c - 'a'] = new TrieNode();
            count++;
        }
        return children[c - 'a'];
    }
};
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        TrieNode* trie = new TrieNode();
        unordered_map<TrieNode*, int> nodes;

        for (int i = 0; i < (int)words.size(); ++i) {
            string word = words[i];
            TrieNode* cur = trie;//字典树
            for (int j = word.length() - 1; j >= 0; --j)//倒序插入
                cur = cur->get(word[j]);
            nodes[cur] = i;
        }

        int ans = 0;
        for (auto& [node, idx] : nodes) {
	//意味着这个节点是个叶子，cur保存着每个word对应的最后一个节点，当它是一个叶子时，我们就该累加这个word的长度+1.
            if (node->count == 0) {
                ans += words[idx].length() + 1;
            }
        }
        return ans;
    }
};
```
## 最大正方形

1.题目
```
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4
```
2.方法一（**动态规划**）

+ 我们用 dp(i,j) 表示以 (i,j) 为右下顶点，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。
+ 对于每个位置 (i,j)，检查在矩阵中该位置的值：
  - 如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；
  - 如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，**这类似于木桶短板效应**。状态转移方程如下：
  ```
  dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1
  ```
+ 实现
```C++
 int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size()==0) return 0;
        int maxSide = 0;
        int rows = matrix.size();
        int cols = matrix[0].size();
        //dp[i][j]表示以(i,j)为正方形右下角顶点的正方形的最大边长
        vector<vector<int>> dp(rows,vector<int>(cols));
        //将边界中为1的位置dp设为1
        for(int i=0;i<rows;i++){
            if(matrix[i][0] == '1'){
                dp[i][0] = 1;
                maxSide = 1;
            }
        }
        for(int i=0;i<cols;i++){
            if(matrix[0][i] == '1'){
                dp[0][i] = 1;
                maxSide = 1;
            }
        }
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                if(matrix[i][j] == '1'){//为'0'的情况不用写，因为已经dp在初始化时就全为0了。
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;;
                }
                maxSide = max(maxSide,dp[i][j]);
            }
        }
        return maxSide*maxSide;
    }
```
3.方法二（暴力解法）

+ 遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；
+ 确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；
+ 每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。
+ 实现
```C++
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    // 遇到一个 1 作为正方形的左上角
                    maxSide = max(maxSide, 1);
                    // 计算可能的最大正方形边长
                    int currentMaxSide = min(rows - i, columns - j);
                    for (int k = 1; k < currentMaxSide; k++) {
                        // 判断新增的一行一列是否均为 1
                        bool flag = true;
                        if (matrix[i + k][j + k] == '0') {
                            break;
                        }
                        for (int m = 0; m < k; m++) {
                            if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        if (flag) {
                            maxSide = max(maxSide, k + 1);
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
```
## 腐烂的橘子

1.题目
```
在给定的网格中，每个单元格可以有以下三个值之一：
值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
```
2.**按位取反的问题**

+ [原码、反码、补码的详细解读](https://blog.csdn.net/wo17fang/article/details/52241682) **补码的定义**:所有的正整数的补码是他本身，所有的负数的补码是对取绝对值后的二进制码取反，加一。
```
[+1] = [00000001]原码 = [00000001]反码 = [00000001]补码

[-1] = [10000001]原码 = [11111110]反码 = [11111111]补码
```
+ 无论是以进制表示还是整数形式赋值给变量，都要根据变量相应的数据类型，表示为补码的形式存储进计算机内存中；
+ 无论是在做数据类型强制转换（内存存储形式没有改变，这一点可以通过查看Memory得到）还是做位运算的时候，实际上都是对  
内存中存储的数进行的操作（也可以查看Memory得到），至于呈现的时候就是根据设定的数据类型把内存中存储的二进制数字进行相应规则的呈现即可 
+ **例子**：
```
////////////////////
8按位取反后的结果(~8)
(1)8的二进制
00000000 00000000 00000000 00001000
(2)取反之后
11111111 11111111 11111111 11110111
(3)由于计算机存储的是补码，按位取反后的结果也被当做补码。
那么左边第一位是符号位，而符号位是1，数值为负。
因此我们处理补码时，先将二进制数-1，然后对除了符号位的二进制数按位取反
10000000 00000000 00000000 00001001 
(4)为-9
/////////////////
同理-1按位取反的结果(~(-1))为0
(1)-1的二进制
11111111 11111111 11111111 11111111
(2)按位取反
00000000 00000000 00000000 00000000
(3)为0
```
3.**if的执行条件**

+ C++ 中 if 语句的语法：
```C++
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
```
+ 如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。**C语言把任何非零和非空的值假定为 true**，把零或 null 假定为 false。 **因此下面的例子可以正常执行if：**
```C++
if(-3){
cout<<success<<endl;
}
```
+ **因此在if判断语句中，如果出现按位取反，只有-1按位取反为0，不会执行if语句，其他数值按位取反后都可以执行**

4. 第一种BFS
+ 观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。
+ 假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(**我们令其为超级源点**)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 −1 ，那么按照广度优先搜索的算法，下一分钟也就是第 0 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。
+ 那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x][y] 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。（有点动态规划那味）
+ 实现
```C++
int cnt;
    int dis[10][10];
    int dir_x[4]={0, 1, 0, -1};//辅助定位即将被腐烂的橘子的横坐标
    int dir_y[4]={1, 0, -1, 0};//辅助定位即将被腐烂的橘子的纵坐标，对应构成腐烂橘子的四个污染方向
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int,int>> Q;//BFS算法标准实现，先进先出，按照腐烂时间顺序保存被腐烂的橘子
        memset(dis, -1, sizeof(dis));
        cnt = 0;
        int n=(int)grid.size(), m=(int)grid[0].size(), ans = 0;
        for (int i = 0; i < n; ++i){
            for (int j = 0; j < m; ++j){
                if (grid[i][j] == 2){
                    Q.push(make_pair(i, j));
                    dis[i][j] = 0;//将一开始就腐烂的橘子当做是被超级源点腐烂的，此时腐烂时间为0.
                }
                else if (grid[i][j] == 1) cnt += 1;
            }
        }
        while (!Q.empty()){
            pair<int,int> x = Q.front();
            Q.pop();
            for (int i = 0; i < 4; ++i){//在腐烂的橘子的四个方向进行移动污染
                int tx = x.first + dir_x[i];
                int ty = x.second + dir_y[i];
                //首先对橘子是否在网给内进行判断，之后判断这个网格内有没有橘子（有橘子才可以污染），
		//同时判断这个橘子是否是没被污染的橘子（如果已经腐烂了的话就不会继续更新腐烂时间了）
                if (tx < 0|| tx >= n || ty < 0|| ty >= m|| dis[tx][ty] >= 0 || !grid[tx][ty]) continue;
                dis[tx][ty] = dis[x.first][x.second] + 1;//被它周围的橘子污染了，腐烂时间+1.
                Q.push(make_pair(tx, ty));//加入队列
                if (grid[tx][ty] == 1){
                    cnt -= 1;//新鲜橘子-1
                    ans = dis[tx][ty];//记录腐烂时间
                    if (!cnt) break;
                }
            }
        }
        return cnt ? -1 : ans;//如果新鲜橘子不为0.那么污染失败返回-1；否则返回污染时间
    }
```
5. 第二种BFS
+ 用正常的 BFS 模板来求最短路径的话，这个队列中第 1 波腐烂的橘子和第 2 波腐烂的橘子的结点会紧挨在一起，无法区分。因此，我们需要稍微修改一下代码，在每一层遍历开始前，记录队列中的结点数量 n ，然后一口气处理完这一层的 n 个结点。

+ 实现
```C++
int orangesRotting(vector<vector<int>>& grid) {
        int min = 0, fresh = 0;
        queue<pair<int, int>> q;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++)
                if(grid[i][j] == 1) fresh++;
                else if(grid[i][j] == 2) q.push({i, j});
        }
        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
        while(!q.empty()) {
            int n = q.size();//标记队列内腐烂橘子个数
            bool rotten = false;//标记这一轮污染是否污染到了新的新鲜橘子
            for(int i = 0; i < n; i++) {
                auto x = q.front();
                q.pop();
                for(auto cur: dirs) {
                    int i = x.first + cur.first;
                    int j = x.second + cur.second;
                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {
                        grid[i][j] = 2;
                        q.push({i, j});
                        fresh--;
                        rotten = true;
                    }
                }
            }
            if(rotten) min++;
        } 
        return fresh ? -1 : min;
    }

```
## x的平方根

1.题目
```
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

输入: 4
输出: 2
```
2.分析
+ 很明显的可以用二分查找算法，这里列出**我自己的实现和答案的区别**：
  - 其实不需要特别判断0~3的情况，然后缩小搜索上界为x/2，因为搜索上界缩小一半其实也只节省了一次二分查找，对计算复杂度影响不大。
  - 注意ans = mid,left = mid + 1这个操作，这样做可以省去最后判断结果要不要-1.
+ 两种实现
```C++
//自己的方法
    int mySqrt(int x) {
        if(x==0) return 0;
        if(x==1||x==2||x==3) return 1;
        int left = 1, right = x/2;
        int res = BinarySearch(x,left,right);
        return res;
    }

    int BinarySearch(int x, int left, int right){
        while(left<right){
            long long mid = (left + right)/2;
            if((mid*mid) == x){
                return mid;
            } 
            if((mid*mid)<x){
               left = mid+1;
            }
            else{
                right = mid-1;
            }  
        }
        if(((long long)left*left<=x)){
            return left;
        }
        else{
            return left-1;
        }   
    }
//答案的方法
int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            }
            else {
                r = mid - 1;
            }
        }
        return ans;
    }
```
## 字符串压缩

1.题目
```
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
输入："aabcccccaaa"
 输出："a2b1c5a3"
输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```
2.**整数转字符串的方法！**

+ 一般来说itoa()函数是一个非标准的C / C++语言功能,因此不能好好的被所有编译器使用。在大多数Windows下的编译器通常在<cstdlib>头文件包含非标准函数。itoa()函数把整数转换成字符串，并返回指向转换后的字符串的指针。
	
+ **一种不使用库函数的模板**

```C++
string temp;
string res;
int count = 12;//任意整数
while(count){
     temp.push_back(count%10+'0');
     count /= 10;
 }
reverse(temp.begin(),temp.end());
for(auto ch : temp){
    res.push_back(ch);
 }
```

+ **使用to_string()函数**注意使用了字符串可以相加的性质
```C++
ans += ch + to_string(cnt); // 注意 cnt 要转为字符串
```
3. 实现
```C++
string compressString(string S) {
        string res;
        int len = S.size();
        if(len == 0||len == 1) return S;
        res.push_back(S[0]);
        int count = 1;
        string temp;
        for(int i=1;i<len;i++){
            if(S[i] == S[i-1]){
                count++;
            }
            else{
                // temp.clear();
                // while(count){
                //     temp.push_back(count%10+'0');
                //     count /= 10;
                // }
                // reverse(temp.begin(),temp.end());
                // for(auto ch : temp){
                //     res.push_back(ch);
                // }
                res += to_string(count);
                res.push_back(S[i]);
                count = 1;
            }
        }
        // temp.clear();
        // while(count){
        //     temp.push_back(count%10+'0');
        //      count /= 10;
        // }
        // reverse(temp.begin(),temp.end());
        // for(auto ch : temp){
        //      res.push_back(ch);
        // }
        res += to_string(count);
        if(res.size()>=len){
            return S;
        }
        else{
            return res;
        }
    }
```
	
## 二叉树的最近公共祖先

1.题目
```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```
2.方法一
+ [此方法的详细解答](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)
+ 最近公共祖先的补充定义： 设节点root 为节点 p,q 的某公共祖先，若其左子节点root.left 和右子节点 root.right 都不是p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。根据以上定义，若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：
  - p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
  - p=root ，且 q 在 root 的左或右子树中；
  - q=root ，且 p 在 root 的左或右子树中；
+ 考虑通过递归对二叉树进行**后序遍历**，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。
+ 终止条件：
  - 当越过叶节点，则直接返回 null ；
  - 当 root 等于 p,q ，则直接返回 root ；
+ 递推工作：
  - 开启递归左子节点，返回值记为 left ；
  - 开启递归右子节点，返回值记为 right ；
+ 返回值： 根据 left 和 right ，可展开为四种情况；
  - 当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；
  - 当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
  - 当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：
    - p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
    - p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
  - 当 leftleft 不为空 ， rightright 为空 ：与情况 3. 同理；
+ 实现
```C++
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL||root->val == p->val||root->val == q->val) return root;//立即返回或终止的条件
        TreeNode* left = lowestCommonAncestor(root->left,p,q);//递归左子树
        TreeNode* right = lowestCommonAncestor(root->right,p,q);//递归右子树
        if(left == NULL&&right == NULL) return NULL;//返回情况1
        if(left == NULL) return right;//返回情况3
        if(right == NULL) return left;//返回情况4
        return root;//返回情况2
    }
```
3.方法二

+ 思路
  - 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
+ 算法
  - 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。
  - 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。
  - 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。
+ 实现
```C++
unordered_map<int, TreeNode*> fa;
    unordered_map<int, bool> vis;
    void dfs(TreeNode* root){//算是后序遍历，并记录父节点吧
        if (root->left != nullptr) {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if (root->right != nullptr) {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        fa[root->val] = nullptr;
        dfs(root);
        while (p != nullptr) {//从p开始往上找父节点（父节点、父节点的父节点....）
            vis[p->val] = true;
            p = fa[p->val];
        }
        while (q != nullptr) {//把q找的父节点与p的作对比，一直对比，直到找到公共祖先
            if (vis[q->val]) return q;
            q = fa[q->val];
        }
        return nullptr;
    }
```
4.方法三（非常朴素且容易想到，就是有些用例会超时）

+ **就是遍历每个结点然后判断以该结点为根结点的遍历序列是否包含p，q**
+ 实现
```Java
class Solution {
    TreeNode res = new TreeNode(0);
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
     isParent(root, p, q);
     return res;  
    }

    public void isParent(TreeNode root, TreeNode p, TreeNode q){ //判断以当前根结点遍历的序列是否包含p，q，包含的话将全局变量res赋值为当前根结点
        Set<Integer> set = new HashSet<Integer>();
        preorderTraverse(root, set);
        if(set.contains(p.val) && set.contains(q.val))
            res = root;
        if(root.left != null)
            isParent(root.left, p, q);
        if(root.right != null)
            isParent(root.right, p, q);
    }

    public void preorderTraverse(TreeNode root, Set<Integer> set){ //先序遍历，建立遍历结点的hashSet；
        if(root != null){
            if(root.left != null)
                preorderTraverse(root.left, set);
            set.add(root.val);
            if(root.right != null)
                preorderTraverse(root.right, set);
        }
    }
```
## 二叉树的直径

1.题目
```
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```
2.分析
+ 假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为L+R。
+ 直接看实现:
```C++
 int ans;
    int depth(TreeNode* root){
        if (root == NULL) return 0; // 访问到空节点了，返回0
        int L = depth(root->left); // 左儿子为根的子树的深度,加上向父节点凸出的一条边
        int R = depth(root->right); // 右儿子为根的子树的深度,加上向父节点凸出的一条边
        ans = max(ans, L + R ); // 计算路径最大值即L+R 并更新ans
        return max(L, R) + 1; // 这一步是精髓！返回该节点为根的子树的深度+1（往上一个节点凸出连接）
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 0;
        depth(root);
        return ans;
    }
```
3.**反思**
+ 自己的算法，大致轮廓：
```C++
pair<int,int> midorder(TreeNode* root, int left, int right){
        if(root->right == NULL||root->left == NULL){
            ...
            }
        pair<int,int> {l1,l2} = midorder(root->left,left+1,right);
        pair<int,int> {r1,r2} = midorder(root->right,left,right+1);
        int l = max(l1,l2);
        int r = max(r1,r2);
        ....//判断最大路径的l和r
	return pair{lx,rx};
```
+ 这样做显然是想在返回时，返回子树最大的直径，同时把它的左右子树的最大直径也返回，这样显然是没有必要的，只需要返回最大的路径即可。

## x的n次幂

1.题目
```
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

输入: 2.00000, 10
输出: 1024.00000
```
2.分析
+ 每一次二分递归计算
```C++
    double quickMul(double x, long long N) {
        if (N == 0) {//任何整数的0次幂都是1，这是退出条件
            return 1.0;
        }
        double y = quickMul(x, N / 2);//递归
	//如果递归中的N是偶数，就直接返回y平方，如果是奇数，因为N/2向下取整了，所以要再乘一个x
        return N % 2 == 0 ? y * y : y * y * x;
    }

    double myPow(double x, int n) {
        long long N = n;//防止N越界
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);//考虑N为负数的情况
    }
```
+ 我们将x^n用自然对数e换底，即可得到：x^n=exp(nlnx)。需要注意的是x取负值的时候，要进行判断。
  - 1.当x < 0 && n % 2 == 0 时，只需将对数函数中的x取绝对值。
  - 2.当x < 0 && n % 2 == 1 时，需将对数函数中的x取绝对值，同时整体取负值。
+ 实现
```C++
     double myPow(double x, int n) {
        if(x == 0)  return 0;
        double ans;
        if(x > 0 || ((x < 0) && (n % 2 == 0)))    ans = exp(n*log(abs(x)));
        else ans = -exp(n*log(-x));
        return ans;
    }
```
## 矩形重叠

**IOU的基本解法，面试常用**

1.题目
```
矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。
如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。
给出两个矩形，判断它们是否重叠并返回结果。

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
```
2.分析
+ 如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。
+ 矩形 rec1 和 rec2 的水平边投影到 x 轴上的线段分别为 (rec1[0], rec1[2]) 和 (rec2[0], rec2[2])。根据数学知识我们可以知道，当 min(rec1[2], rec2[2]) > max(rec1[0], rec2[0]) 时，这两条线段有交集。对于矩形 rec1 和 rec2 的竖直边投影到 y 轴上的线段，同理可以得到，当 min(rec1[3], rec2[3]) > max(rec1[1], rec2[1]) 时，这两条线段有交集。
+ 实现
```C++
 bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        bool res = (min(rec1[2],rec2[2])>max(rec1[0],rec2[0]))&&
                    (min(rec1[3],rec2[3])>max(rec1[1],rec2[1]));
        return res;
    }
```
## 最小栈
1. 题目
```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
```
2.方法一
+ 对于栈来说，如果一个元素 a 在入栈时，栈里有其它的元素 b, c, d，那么无论这个栈在之后经历了什么操作，只要 a 在栈中，b, c, d 就一定在栈中，因为在 a 被弹出之前，b, c, d 不会被弹出。因此，在操作过程中的任意一个时刻，只要栈顶的元素是 a，那么我们就可以确定栈里面现在的元素一定是 a, b, c, d。
+ 那么，我们可以在每个元素 a 入栈时把当前栈的最小值 m 存储起来。在这之后无论何时，如果栈顶元素是 a，我们就可以直接返回存储的最小值 m。
+ 按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。
  - 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；
  - 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；
  - 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中
+ 实现
```C++
    stack<int> res;
    stack<int> min_res;//辅助栈，用来存放每个元素入栈时，栈的最小值
    /** initialize your data structure here. */
    MinStack() {
        min_res.push(INT_MAX);//这样在push时不用考虑当前min_res栈是不是为空
    }
    
    void push(int x) {
        min_res.push(min(x,min_res.top()));
        res.push(x);
    }
    
    void pop() {
        res.pop();
        min_res.pop();
    }
    
    int top() {
        return res.top();
    }
    
    int getMin() {
        return min_res.top();
    }
```
3.方法二
+ **使用链表实现**
```C++
class MinStack {
private:
	struct Node {
		int val=0;
		int min=2147483647;//2^31-1 int能表示的最大值
		Node *next=nullptr;
	};
public:
    Node *head = new Node;
	void push(int x) {
		Node *node = new Node;
		node->val = x;
		node->min = head->min < x ? head->min : x;
		node->next = head;
		head = node;
	}
	void pop() {
		head = head->next;
	}
	int top() {
		return head->val;
	}
	int getMin() {
		return head->min;
	}
};
```
## 二叉树的层序遍历

1.题目
```
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```
2.**一种新的二维vector初始化和赋值方法**
+ 二维vector赋值时若没有初始化，那么不好一个一个赋值，因此按行赋值的一般方法为：
```C++
vector<vector<int>> res;
vector<int> layer;
...layer的一些操作
if(layer.size() != 0){
   res.push_back(layer);//把一层节点的值，统一push进res中
 }
```
+ 一种新的方法
  - 在每一行vector,进行逐个赋值ret.back().push_back(node->val);
  - 在最后添加一个ret.push_back(vector <int> ());

```C++
 while (!q.empty()) {
        int currentLevelSize = q.size();
        ret.push_back(vector <int> ());//全新的二维vector赋值方法
        for (int i = 1; i <= currentLevelSize; ++i) {
            auto node = q.front(); q.pop();
            ret.back().push_back(node->val);//逐个赋值
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
```

3.分析
+ 首先根元素入队，当队列不为空的时候
+ 求当前队列的长度 len ,依次从队列中取 len 个元素进行拓展，然后进入下一次迭代
+ BFS的第一种实现（自己的算法）
```C++
 int depth;
    vector<vector<int>> res;//存放结果
    queue<TreeNode*> track;//队列存放每一层的树节点
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == NULL) return {};
        vector<int> layer;//存放每一层的节点的值，最后统一push进res中
        layer.push_back(root->val);
        res.push_back(layer);//先把根节点的值放进去
        track.push(root);//根节点入队列
        while(!track.empty()){
            layer.clear();
            int len = track.size();
            for(int i=0;i<len;i++){//以每一层节点个数作为队列循环的次数
                auto node = track.front();
                track.pop();
                if(node->left != NULL){
                    track.push(node->left);
                    layer.push_back(node->left->val);
                }
                if(node->right != NULL){
                    track.push(node->right);
                    layer.push_back(node->right->val);
                }
            }
            if(layer.size() != 0){
                res.push_back(layer);//把一层节点的值，统一push进res中
            }
        }
        return res;
    }
```
+ BFS的第二种实现
```C++
vector<vector<int>> levelOrder(TreeNode* root) {
        vector <vector <int>> ret;
        if (!root) return ret;

        queue <TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int currentLevelSize = q.size();
            ret.push_back(vector <int> ());//全新的二维vector赋值方法
            for (int i = 1; i <= currentLevelSize; ++i) {
                auto node = q.front(); q.pop();
                ret.back().push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        
        return ret;
    }
```
## 只出现一次的数字

1.题目
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

输入: [2,2,1]
输出: 1
```
2.分析(**经典的位运算算法**)
+ 使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。
  - 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
  - 任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
  - 异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。
+ 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。
+ 实现
```C++
int singleNumber(vector<int>& nums) {
        int ret = 0;
        for (auto e: nums) ret ^= e;
        return ret;
    }
```
## 和为k的子数组
1.题目
```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
2.前缀和
+ 前缀和：
  - 从第 0 项到当前项的总和
+ 如果用一个数组表示：
  - prefixSum[x]：nums 数组的第 0 项到第 x 项的总和prefixSum[x]=nums[0]+nums[1]+…+nums[x]
  - 所以有，nums 某一项 = 两个相邻前缀和之差：nums[x]=prefixSum[x]−prefixSum[x−1]
  - 所以有，nums 数组 从 i 到 j 项 的和：nums[i]+…+nums[j]=prefixSum[j]−prefixSum[i−1]
  - i 可以为 0 ，则 i - 1 为 - 1，我们让 prefixSum[-1] 为 0
3.分析
- map 存什么键值对：
  - 键： 前缀和，即从第 0 项到当前项的总和
  - 值： 前缀和为这个值出现了几次
+ 在遍历 nums 数组之前，我们让前缀和初始值为 0（即 prefixSum[-1] = 0）。即 map 初始放入{0,1}键值对
+ 遍历 nums 的每一项，求当前项的前缀和，存入 map 做记录
  - 之前没有存过，则存入，初始值为 1
  - 之前存过，则对应值 +1，即出现次数 +1
  - 如果遍历过程中发现，map 中**已存在**key是**当前前缀和 - k**
    - 说明存在 【之前求出的前缀和】，它的值满足 【当前前缀和】-【之前求出的前缀和】 === k
    - 把 【之前求出的前缀和】 出现的次数，累加给 count 计数器
+ 实现
```C++
//双指针暴力法
int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        for (int start = 0; start < nums.size(); ++start) {
            int sum = 0;
            for (int end = start; end >= 0; --end) {
                sum += nums[end];
                if (sum == k) {
                    count++;
                }
            }
        }
        return count;
    }
//前缀和+哈希表算法
int subarraySum(vector<int>& nums, int k) {
        //键：按从左往右顺序，依次相加整数的前缀和；值：在依次相加过程中，某个前缀和出现的次数
        unordered_map<int,int> res;
        int sum = 0;
        int count = 0;
        //容易遗漏的一步！这一步是初始化，这样从0开始累加，并达到k的情况才能被考虑到。
        res.insert({0,1});
        for(auto num : nums){
            sum += num;
            // 如果前面n个数字之和sum，减去k的值正好可以在map中找到
            // 说明之前存在一组连续数字的前缀和为sum-k,那么从这组数字的末尾到n的和正好为k
            //计数+1
            if(res.find(sum-k) != res.end()){
                count += res[sum-k];
            } 
            res[sum]++;
        }
        return count;
    }
```
## k个一组翻转链表

1.题目
```
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5
```

2.分析
+ ![流程图](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/images/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.png)
+ 链表分区为已翻转部分+待翻转部分+未翻转部分
+ 每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定
+ 需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来
+ 初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾
+ 经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end->next
+ 翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环
+ 特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可
+ 实现
```C++
ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* sentinel = new ListNode(0);//哨兵节点
        sentinel->next = head;
        ListNode* pre = sentinel;//待翻转的部分链表的前驱
        ListNode* end = sentinel;//待翻转的部分链表的末尾
        while(end->next){
            for(int i=0;i<k&&end;i++){
                end = end->next;
            }
            if(end == NULL) break;//最后链表末尾不够k个一组了，到达末尾，就直接不翻转跳出。
            ListNode* start = pre->next;//表示待翻转的部分链表的头结点
            ListNode* next = end->next;//下一个待翻转部分链表的头结点
            end->next = NULL;//断开待翻转的部分链表与后面链表的链接
            pre->next = Reverse(start);//链接前面链表与当前翻转好的链表。翻转后end在链表头,start在链表尾
            start->next = next;//链接下一个待翻转的部分链表
            pre = start;//pre指向待翻转的部分链表的前驱
            end = pre;//end跟进pre
        }
        return sentinel->next;
    }
    //翻转链表
    ListNode* Reverse(ListNode* head){
        ListNode* cur = NULL;
        ListNode* pre = head;
        while(pre){
            ListNode* temp = pre->next;
            pre->next = cur;
            cur = pre;
            pre = temp;
        }
        return cur;
    }
```
## 课程表II
1.题目
```
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```
2.拓扑排序和有向图
+ 给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：
  - **对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面**
  - 那么称该排列是图 G 的「拓扑排序」。
+ 推论：如果图 G 中存在环（即图 GG 不是「有向无环图」），那么图 G 不存在拓扑排序。
+ 推论：如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。

3.分析
+ 我们将每一门课看成一个节点；
+ 如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。

4.DFS算法
+ 利用栈后进先出的性质，进行按有向图的方向深度搜索，先把只有入度，没有出度的课程节点加入栈。之后进行回溯，再深度搜索其他课程节点。
+ 对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。
+ 实现
```C++
class Solution {
private:
    // 存储有向图
    vector<vector<int>> edges;
    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成
    vector<int> visited;
    // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶
    vector<int> result;
    // 判断有向图中是否有环
    bool invalid;

public:
    void dfs(int u) {
        // 将节点标记为「搜索中」
        visited[u] = 1;
        // 搜索其相邻节点
        // 只要发现有环，立刻停止搜索
        for (int v: edges[u]) {
            // 如果「未搜索」那么搜索相邻节点
            if (visited[v] == 0) {
                dfs(v);
                if (invalid) {
                    return;
                }
            }
            // 如果「搜索中」说明找到了环
            else if (visited[v] == 1) {
                invalid = true;
                return;
            }
        }
        // 将节点标记为「已完成」
        visited[u] = 2;
        // 将节点入栈
        result.push_back(u);
    }
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto& info: prerequisites) {
            edges[info[1]].push_back(info[0]);
        }
        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索
        for (int i = 0; i < numCourses && !invalid; ++i) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        if (invalid) {
            return {};
        }
        // 如果没有环，那么就有拓扑排序
        // 注意下标 0 为栈底，因此需要将数组反序输出
        reverse(result.begin(), result.end());
        return result;
    }
};
```
5.BFS算法
+ 考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。
+ 使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。
  - 在广度优先搜索的每一步中，取出队首的节点 u：
  - 将 u 放入答案中；
  - 我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为0，那么我们就将 v 放入队列中。
+ 在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，**否则说明图中存在环，也就不存在拓扑排序了**。
+ 实现
```C++
    vector<vector<int>> edges;//存储有向图
    vector<int> indeg;//存储每个节点的入度
    vector<int> result;//存储最终课程排序结果
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        //使用队列保存入度为0的节点(入度为0，即为此课程需要先修的课程都修完了)
        queue<int> bfs;
        edges.resize(numCourses);
        indeg.resize(numCourses);
        //初始化有向图，方向为先修课程指向依赖此先修课程的其他课程。
        for(auto info : prerequisites){
            edges[info[1]].push_back(info[0]);
            indeg[info[0]] ++;
        }
        for(int i=0;i<indeg.size();i++){//将一开始就入度为0的点加入队列
            if(indeg[i] == 0){
                bfs.push(i);
            }
        }
        while(!bfs.empty()){//开始广度优先搜索
            auto course = bfs.front();
            bfs.pop();
            result.push_back(course);//先将队列头添加入答案
            for(auto depend_course : edges[course]){//将依赖于对队列头课程的课程，入度-1.
                indeg[depend_course]--;
                if(indeg[depend_course] == 0){//如果这些课程入度为0，入队列
                    bfs.push(depend_course);
                }
            }
        }
        if(result.size() == numCourses){
            return result;
        }
        else{
            return {};
        }
    }
```
## 乘积最大子数组
1.题目
```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```
2.分析
+ 使用dp[i]表示以第i个数字结束的子数组，乘积的最大值。
+ 考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个min_dp[i]，它表示以第 i 个元素结尾的乘积最小子数组的乘积.
+ 实现
```C++
int maxProduct(vector<int>& nums) {
        vector<int> max_dp(nums.size());
        vector<int> min_dp(nums.size());
        int res;
        max_dp[0] = nums[0];
        min_dp[0] = nums[0];
        res = max_dp[0];
        for(int i=1;i<nums.size();i++){//关注如何迭代求解最大乘积max_dp[i]和最小乘积min_dp[i]
            max_dp[i] = max(max(max_dp[i-1]*nums[i],nums[i]),min_dp[i-1]*nums[i]);
            min_dp[i] = min(min(min_dp[i-1]*nums[i],nums[i]),max_dp[i-1]*nums[i]);
            res = max(res,max_dp[i]);
        }
        return res;
    }
```
## 验证回文字符串II
1.题目
```
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

输入: "aba"
输出: True
```
2.string中的erase函数
+ erase函数的原型如下：
```C++
string& erase(size_t pos = 0, size_t n = npos);
iterator erase(iterator position);
iterator erase(iterator first, iterator last);
```
+ 也就是说有三种用法：
```C++
erase(pos,n);//删除从pos开始的n个字符，比如erase(0,1)就是删除第一个字符
erase(position);//删除position处的一个字符(position是个string类型的迭代器)
erase(first,last);//删除从first到last之间的字符（first和last都是迭代器）
```

3.分析
+ 定义左右指针，初始时分别指向字符串的第一个字符和最后一个字符，每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。
+ 在允许最多删除一个字符的情况下，同样可以使用双指针，通过贪心算法实现。初始化两个指针 left 和 right 分别指向字符串的第一个字符和最后一个字符。每次判断两个指针指向的字符是否相同，如果相同，则更新指针，令 left = left + 1 和 right = right - 1，然后判断更新后的指针范围内的子串是否是回文字符串。+ 如果两个指针指向的字符不同，则两个字符中必须有一个被删除，此时我们就分成两种情况：即删除左指针对应的字符，留下子串 s[left + 1], ..., s[right]，或者删除右指针对应的字符，留下子串 s[left], ..., s[right - 1]。当这两个子串中至少有一个是回文串时，就说明原始字符串删除一个字符之后就以成为回文串。
+ 实现
```C++
// 会超时
    // bool validPalindrome(string s) {
    //     if(s.size() == 1 || s.size() == 2) return true;
    //     for(int i=0;i<s.size();i++){
    //         string temp1 = s;
    //         temp1.erase(i,1);
    //         string temp2 = temp1;
    //         reverse(temp1.begin(),temp1.end());
    //         if(temp1 == temp2){
    //             return true;
    //         }
    //     }
    //     return false;
    // }
    bool decision(string& s, int left, int right){
        for(;left<right;left++,right--){
            if(s[left] != s[right]){
                return false;
            }
        }
        return true;
    }
    bool validPalindrome(string s) {
        if(s.size() == 1 || s.size() == 2) return true;
        int left = 0;
        int right = s.size()-1;
        for(;left<right;left++,right--){
            if(s[left] == s[right]){
                continue;
            }
            else{
                return decision(s,left+1,right)||decision(s,left,right-1);
            }
        }
        return true;
    }
```
## 每个元音包含偶数次的最长子字符串
1.题目
```
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```
2.分析
+ 首先题目中要求子字符串中每个元音字母恰好出现偶数次，我们就可以使用 0 和 1 来标识每个字母的状态(偶数次或奇数次)，我们不需要知道每个字母出现的完整次数，只需要知道这个次数的奇偶性。
+ 那么我们可以注意到奇数次 + 1 = 偶数次，偶数次 + 1 = 奇数次，所以我们可以使用 异或 来参与运算：比如 aba
  - 初始时 status = 00000，然后到 a 的时候 00000 ^ 00001 = 00001，1 说明 a 出现奇数次
  - 然后到 b 的时候 00001 ^ 00010 = 00011，两个 1 说明 a、b 都出现奇数次
  - 最后到 a 的时候 00011 ^ 00001 = 00010，说明只有 b 出现奇数次了。
  - 以上也说明我们确实是可以使用状态码去标识每个元音字母出现次数的奇偶性。
+ 之后讨论哪些子串符合要求，因为现在每个下标对应的状态码其实也就只有 0 和 1
  - 如果坐标 i 对应的状态码是 00011，坐标 j 对应的状态码是 00011，那么他们俩中间的元音字母数一定是偶数，如果某一位不相同，那么绝对不可能是偶数，因为偶数-奇数=奇数，奇数-偶数=奇数
  - 所以每次求出一个坐标的状态码的时候查询这个状态码前面是否存在，如果存在，那么就计算一下之间子字符串的长度就 ok 了，需要一个hash表，存储每个状态码对应的下标！当然因为我们状态码最长也就是 11111 = 2^5 - 1 = 31，开一个 32 大小的数组就好了。
+ 实现
```C++
 int findTheLongestSubstring(string s) {
        int ans = 0, status = 0, n = s.size();
        vector<int> pos(32, -1);
        pos[0] = 0;
        for (int i = 0; i < n; i ++) {
            if (s[i] == 'a') {
                status ^= 1<<0;
            } else if (s[i] == 'e') {
                status ^= 1<<1;
            } else if (s[i] == 'i') {
                status ^= 1<<2;
            } else if (s[i] == 'o') {
                status ^= 1<<3;
            } else if (s[i] == 'u') {
                status ^= 1<<4;
            }
            if (pos[status] != -1) {
                ans = max(ans, i + 1 - pos[status]);
            } else {
                pos[status] = i + 1;
            }
        }
        return ans;
    }
```
## 使数组唯一的最小增量
1.题目
```
给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。
返回使 A 中的每个值都是唯一的最少操作次数。
输入：[3,2,1,2,1,7]
输出：6
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。
```
2.sort排序
+ 先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。
+ **这是一种比较朴素，应该尽快想到的思路**
+ 实现
```C++
int minIncrementForUnique(vector<int>& A) {
    // 先排序
    sort(A.begin(),A.end());
    int move = 0;
    // 遍历数组，若当前元素小于等于它的前一个元素，则将其变为前一个数+1
    for (int i = 1; i < A.size(); i++) {
        if (A[i] <= A[i - 1]) {
            int pre = A[i];
            A[i] = A[i - 1] + 1;
            move += A[i] - pre;
        }
    }
    return move;
}
```
3.计数排序
+ 实现
```C++
int minIncrementForUnique(vector<int> A) {
        // counter数组统计每个数字的个数。
        //（这里为了防止下面遍历counter的时候每次都走到40000，所以设置了一个max，这个数据量不设也行，再额外设置min也行）
        vector<int> counter(40001);
        int maxnum = -1;
        for (int num: A) {
            counter[num]++;
            maxnum = max(maxnum, num);
        }
        
        // 遍历counter数组，若当前数字的个数cnt大于1个，则只留下1个，其他的cnt-1个后移
        int move = 0;
        for (int num = 0; num <= max; num++) {
            if (counter[num] > 1) {
                int d = counter[num] - 1;
                move += d;
                counter[num + 1] += d;
            }
        }
        // 最后, counter[max+1]里可能会有从counter[max]后移过来的，counter[max+1]里只留下1个，其它的d个后移。
        // 设 max+1 = x，那么后面的d个数就是[x+1,x+2,x+3,...,x+d],
        // 因此操作次数是[1,2,3,...,d],用求和公式求和。
        int d = counter[max + 1] - 1;
        move += (1 + d) * d / 2;
        return move;
    }
```
4.线性探测 + 路径压缩
+ [参考这篇解析](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/)
+ **这道题目和解决 hash 冲突的线性探测法比较相似**
  - 如果地址冲突了，会探测它的下一个位置，如果下一个位置还是冲突，继续向后看，直到第一个不冲突的位置为止。
  - 关键点：因为直接线性探测可能会由于冲突导致反复探测耗时太长，因此我们可以考虑探测的过程中进行路径压缩。
    - 经过某条路径最终探测到一个空位置 x 后，将这条路径上的值都变成空位置所在的下标 x，那么假如下次探测的点又是这条路径上的点，则可以直接跳转到这次探测到的空位置 x，从 x 开始继续探测。
+ 实现：
```C++
int minIncrementForUnique(vector<int>& A) {
        if (A.empty()) return 0;
        int res = 0;
        // -1表示空位
        vector<int> pos(80000, -1); 
        // 遍历每个数字a对其寻地址得到位置b, b比a的增量就是操作数。
        for (int a: A)
        {
            int b = findPos(a, pos);
            res += b-a;
        }
        return res;
    }
    // 线性探测寻址(状态压缩)
    int findPos(int a, vector<int> &pos)
    {
        int b = pos[a];
        // a对应的位置pos[a]是空位，直接放入
        if (b==-1)
        {
            pos[a] = a;
            return a;
        }
        // 关键一步！向后寻址(这一步隐含了状态压缩的跳转)
        b = findPos(b+1, pos);
        pos[a] = b;
        return b;
    }
```
## 字符串的最大公因子
1.题目
```
对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。
返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

输入：str1 = "ABCABC", str2 = "ABC"
输出："ABC"
```
2.__ gcd()函数
+ 最大公约数（greatest common divisor，简写为gcd；或highest common factor，简写为hcf）
+ __ gcd(x,y)是algorithm库中的函数

3.方法一：枚举
+ 首先答案肯定是字符串的某个前缀，然后简单直观的想法就是枚举所有的前缀来判断，我们知道前缀串的长度必然要是两个字符串长度的约数才能满足条件，否则无法经过若干次拼接后得到长度相等的字符串
+ 所以可以枚举符合长度条件的前缀串，再去判断这个前缀串拼接若干次以后是否等于 str1 和 str2 即可。
+ 由于题目要求最长的符合要求的字符串 X，所以可以按长度从大到小枚举前缀串，这样碰到第一个满足条件的前缀串返回即可。
+ 实现
```C++
string gcdOfStrings(string str1, string str2) {
        string res = "";
        string temp;
        int len1 = str1.length();
        int len2 = str2.length();
        int len = min(len1,len2);
        for(int i=len;i>0;i--){
            temp = str1.substr(0,i);
            if(decision(str1,temp)&&decision(str2,temp)){
                res= temp;
                break;
            }
        }
        return res;
    }
    bool decision(string s, string t){
        int times = s.size()/t.size();
        string s_copy;
        for(int i=0;i<times;i++){
            s_copy += t;
        }
        return s_copy == s;
    }
```
4.方法二：求最大公约数
+ 注意到一个性质：**如果存在一个符合要求的字符串 X，那么也一定存在一个符合要求的字符串 X'，它的长度为 str1 和 str2 长度的最大公约数。**
+ 实现
```C++
class Solution {
    bool check(string t,string s){
        int lenx = (int)s.length() / (int)t.length();
        string ans = "";
        for (int i = 1; i <= lenx; ++i){
            ans = ans + t;
        }
        return ans == s;
    }
public:
    string gcdOfStrings(string str1, string str2) {
        int len1 = (int)str1.length(), len2 = (int)str2.length();
        string T = str1.substr(0, __gcd(len1,len2)); // __gcd() 为c++自带的求最大公约数的函数
        if (check(T, str1) && check(T, str2)) return T;
        return "";
    }
};
```
## 最小覆盖子串
1.题目
```
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```
2.分析
+ 我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。
+ 用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。
+ 实现：
```C++
 unordered_map <char, int> ori, cnt;//ori表示t字符串的哈希表，cnt表示s字符串的哈希表
    bool check() {//如果t中字符（包含重复的字符）都可以在s的子串中找到，就返回真
        for (const auto &p: ori) {
            if (cnt[p.first] < p.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
        for (const auto &c: t) {
            ++ori[c];
        }

        int l = 0, r = -1;
        int len = INT_MAX, ansL = -1, ansR = -1;

        while (r < int(s.size())) {
            if (ori.find(s[++r]) != ori.end()) {//先向右移动r，如果s[r]在t中出现，计数+1
                ++cnt[s[r]];
            }
            while (check() && l <= r) {//如果s的子串包含t中字符，且左指针小于右指针
                if (r - l + 1 < len) {//如果子串长度小于目前最优解，则更新最小覆盖子串
                    len = r - l + 1;
                    ansL = l;
                }
                if (ori.find(s[l]) != ori.end()) {
                    --cnt[s[l]];//减去计数，并向右移动l指针
                }
                ++l;
            }
        }

        return ansL == -1 ? string() : s.substr(ansL, len);
    }
```
## LRU缓存机制
1.题目
```
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

RUCache cache = new LRUCache( 2 /* 缓存容量 */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```
2.分析
+ LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。
  - 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。
  - 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。
+ 对于 get 操作，首先判断 key 是否存在：
  - 如果 key 不存在，则返回 -1；
  - 如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。
+ 对于 put 操作，首先判断 key 是否存在：
  - 如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；
  - 如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。
+ **在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。**

3.实现
```C++
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};
```
## 寻找重复数
1.题目
```
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

输入: [1,3,4,2,2]
输出: 2
```
2.分析
+ **二分法使用前提**：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n）。
+ 这道题要求查找的数是一个整数，并且给出了这个整数的范围（在 1 和 n 之间，包括 1 和 n），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数；
+ 二分法的思路是先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt，如果 cnt **严格大于** mid，。根据抽屉原理，重复元素就在区间 [left, mid] 里；
+ 实现
```
 int findDuplicate(vector<int> &nums) {
        int len = nums.size();
        int left = 1;
        int right = len - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            int cnt = 0;
            for (int num:nums) {
                if (num <= mid) {
                    cnt++;
                }
            }

            // 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，
            // 此时重复元素一定出现在 [1, 4] 区间里

            if (cnt > mid) {
                // 重复的元素一定出现在 [left, mid] 区间里
                right = mid;
            } else {
                // if 分析正确了以后，else 搜索的区间就是 if 的反面
                // [mid + 1, right]
                // 注意：此时需要调整中位数的取法为上取整
                left = mid + 1;
            }
        }
        return left;
    }
```
## 和可被K整除的子数组

**通常，涉及连续子数组问题的时候，使用前缀和来解决！！**

1.题目
```
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```
2.分析
+ 令 P[i]=A[0]+A[1]+...+A[i]。那么每个连续子数组的和 sum(i,j) 就可以写成P[j]−P[i−1]（其中 0<i<j）的形式。此时，判断子数组的和能否被 K 整除就等价于判断 (P[j]−P[i−1])modK==0，根据 同余定理，只要P[j]modK==P[i−1]modK，就可以保证上面的等式成立。
+ 因此可以考虑对数组进行遍历，在遍历同时统计答案。当我们遍历到第 i 个元素时，我们统计以 i 结尾的符合条件的子数组个数。我们可以维护一个以前缀和模 K 的值为键，出现次数为值的哈希表 record，在遍历的同时进行更新。这样在计算以 i 结尾的符合条件的子数组个数时，根据上面的分析，答案即为 [0..i−1] 中前缀和模 K 也为 P[i]modK 的位置个数，即record[P[i]modK]。
+ 最后的答案即为以每一个位置为数尾的符合条件的子数组个数之和。需要注意的一个边界条件是，我们需要对哈希表初始化，记录 record[0]=1，这样就考虑了前缀和本身被 K 整除的情况。
+ 实现
```C++
int subarraysDivByK(vector<int>& A, int K) {
        unordered_map<int, int> record = {{0, 1}};
        int sum = 0, ans = 0;
        for (int elem: A) {
            sum += elem;
            // 注意 C++ 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
            int modulus = (sum % K + K) % K;
            if (record.count(modulus)) {
                ans += record[modulus];
            }
            ++record[modulus];
        }
        return ans;
    }
```
3. 方法2
+ 相对于方法一，**我们可以在遍历只维护哈希表。在遍历结束后，我们再遍历哈希表，用排列组合的方法来统计答案**。
+ 对于哈希表中的每个键值对 (x, c_x)，它表示前缀和 x（在模 K 的意义下）出现了 c_x次。那么这些出现的位置两两之间都可以构成可被 K 整除的连续子数组，数量即为 cx * (cx - 1) / 2个可被 K 整除的连续子数组。例如当 c_x = 5时，那么两两组合共有5*4/2 = 10 =10 个子数组。
+ 实现
```C++
int subarraysDivByK(vector<int>& A, int K) {
        unordered_map<int, int> record = {{0, 1}};
        int sum = 0;
        for (int elem: A) {
            sum += elem;
            // 注意 C++ 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
            int modulus = (sum % K + K) % K;
            ++record[modulus];
        }

        int ans = 0;
        for (auto [x, cx]: record) {
            ans += cx * (cx - 1) / 2;
        }
        return ans;
    }
```
## 字符串解码
1.题目
```
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
```
2.分析
+ 实现方法一：
```C++
stack<int> multi_times;//后进先出，保存复制倍数
    stack<string> ans_stack;//进入一个[]前，保存阶段性string结果
    string ans;//累积字母，并保存最终结果
    int multi = 0;
    string decodeString(string s) {
        if(s.size() == 0) return "";
        for(auto ch : s){
            if(isdigit(ch)){
                multi = multi*10+ch-'0';//倍数可能不止一个数字
            }
            else if(ch == '['){
                ans_stack.push(ans);//进入一个[]前，将进入前已有的部分字符串结果入栈
                multi_times.push(multi);//将复制字符串的倍数入栈
                ans.clear();//暂时清空ans
                multi = 0;//倍数置零
            }
            else if(isalpha(ch)){
                ans += ch;//ans中累计字母
            }
            else{//在出一个[]时，将原有字符串结果+当前ans累积字母×复制倍数
                string temp = ans_stack.top();
                ans_stack.pop();
                int times = multi_times.top();
                multi_times.pop();
                for(int i=0;i<times;i++){
                    temp += ans;
                }
                ans = temp;//更新ans，为以后再出[]做准备。
            }
        }
        return ans;
    }
```
+ 实现方法二：
```C++
string getDigits(string &s, size_t &ptr) {
        string ret = "";
        while (isdigit(s[ptr])) {
            ret.push_back(s[ptr++]);
        }
        return ret;
    }
    string getString(vector <string> &v) {
        string ret;
        for (const auto &s: v) {
            ret += s;
        }
        return ret;
    }
    string decodeString(string s) {
        vector <string> stk;
        size_t ptr = 0;

        while (ptr < s.size()) {
            char cur = s[ptr];
            if (isdigit(cur)) {
                // 获取一个数字并进栈
                string digits = getDigits(s, ptr);
                stk.push_back(digits);
            } else if (isalpha(cur) || cur == '[') {
                // 获取一个字母并进栈
                stk.push_back(string(1, s[ptr++])); 
            } else {
                ++ptr;
                vector <string> sub;
                while (stk.back() != "[") {
                    sub.push_back(stk.back());
                    stk.pop_back();
                }
                reverse(sub.begin(), sub.end());
                // 左括号出栈
                stk.pop_back();
                // 此时栈顶为当前 sub 对应的字符串应该出现的次数
                int repTime = stoi(stk.back()); 
                stk.pop_back();
                string t, o = getString(sub);
                // 构造字符串
                while (repTime--) t += o; 
                // 将构造好的字符串入栈
                stk.push_back(t);
            }
        }

        return getString(stk);
    }
```
## 打家劫舍
1.题目
```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
2.**分析**
+ [此类典型的动态规划问题教程](https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%8A%A2%E6%88%BF%E5%AD%90.md)
+ 如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第k~(k>2)间房屋，有两个选项：
  - 偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。
  - 不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。
+ 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。
+ 用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：
  - dp[i]=max(dp[i−2]+nums[i],dp[i−1])
+ 实现
```
    int rob(vector<int>& nums) {
        if(nums.size()==0){
            return 0;
        }
        if(nums.size()==1){
            return nums[0];
        }
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(dp[0],nums[1]);
        for(int i=2;i<nums.size();i++){
            dp[i] = max(dp[i-1],(dp[i-2]+nums[i]));
        }
        return dp[nums.size()-1];
    }
```




## No.208也是字典树！！
+ **总结各种动态规划、BFS、DFS、滑窗算法的模板！！！！**
+ **把关于二叉树的算法都好好总结一下**
+ **hash表的实现原理，线性探测？**
+ **连续数组的问题与前缀和的关系？**
+ **编译原理+巴斯克范式？+有限状态机（DFA）**
+ **剑指offer刷起来**
+ [一个大量模板的博客](https://blog.csdn.net/fuxuemingzhu/article/details/101900729)
## 一个BFS的小小模板(借鉴了No.994)
```
//1.如果不需要确定当前遍历到了哪一层
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)
//2.如果要确定当前遍历到了哪一层
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
   level ++;
```
