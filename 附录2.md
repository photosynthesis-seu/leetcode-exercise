# 本附录包含题目：
```
面试题08.11.硬币（动态规划/背包问题）No.322零钱兑换（典型动态规划）
```
## 面试题08.11.硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## No.322 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析

[见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
