# 本附录包含题目：
```
面试题08.11.硬币（动态规划/二维数组背包问题）面试题51 数组中的逆序对（归并排序,copy函数，涉及从标准输入设备读取信息！）
面试题56-I 数组中数字出现的次数（位运算与运算符优先级）
面试题57 - II. 和为s的连续正数序列（滑动窗口算法）
面试题 01.06. 字符串压缩(遍历算法、字符串相加、to_string函数实现整数转字符串、自己实现整数转字符串)
No.3 无重复字符的最长子串（双指针、滑窗算法，动态规划，unordered_set）
No.30 串联所有单词的子串（滑窗算法，unordered_map,比较复杂）
No.35 搜索插入位置（带特判的二分查找）
No.39 组合总数（需要列举完全背包问题每种情况/面试题08.11.硬币的细化、回溯算法+剪枝）
No.40 组合总和（回溯算法+巧妙的剪枝）
No.45 跳跃游戏II(贪心算法！自己的递归会超时)
No.46 全排列（递归+回溯算法+DFS）
No.61 旋转链表(双指针)
No.69 x的平方根（二分查找、牛顿迭代算法）
No.75 颜色分类 
No.98 验证二叉搜索树（递归helper(root, ower,upper)，中序遍历 ）
No.124 二叉树中的最大路径和（dfs,带返回的递归问题）
No.125 验证回文串（各种内置函数：isdigt/islower/isupper）
No.172 阶乘后的零（数学技巧、腾讯面试题）
No.202 快乐数（数学技巧，unordered_set的使用,双指针的快慢指针算法）
No.221 最大正方形（典型的动态规划，需要关注暴力解法）
No.225 用队列实现栈 No.232 用栈实现队列(注意循环的判断条件，如果修改栈，就不要用栈的大小判断，很关键！)
No.236 二叉树的最近公共祖先（递归的后序遍历算法、哈希表存储父节点、以及一种很朴素容易想到但是个别用例超时的算法！）
No.315 计算右侧小于当前元素的个数(归并算法+vector<pair<int,int>>索引容器) 
No.322 零钱兑换（典型动态规划）
No.365 水壶问题（BFS/DFS、数学问题、lambda表达式、unordered_set重载hash函数）
No.572 另一个树的子树（典型的dfs+递归（考虑前、中序遍历问题）、KMP字符串匹配算法）
No.793 阶乘函数后K个零（二分查找，腾讯面试题变种）
No.820 单词的压缩编码（字典树，unorded_set,unordered_map）
No.983 最低票价（从后向前的动态规划，unordered_set，正确初始化类成员变量）
No.992 排序数组（各种排序算法！）
No.994 腐烂的橘子（典型题目！两种多源BFS的算法（两种算法的实现都很有技巧且很多细节不同，都要会）、按位取反、if的执行条件、带点动态规划那味）
No.1095 山脉数组中查找目标值（二分查找）

```
二分查找的一些题目（未做）
```
No.33/No.81 搜索旋转排序数组 No.153/154 搜搜旋转数组中的最小值 No.69 平方根 No.287寻找重复数
No.875 爱吃香蕉的珂珂 No.1300 转变数组后最接近目标值的数组和 No.410 分割数组的最大值
```
滑动窗口的一些题目（未做）
```
No.3 无重复字符的最长子串 No.30 串联所有单词的子串NO.76 最小覆盖子串 No.159 至多包含两个不同字符的最长子串
No.209 长度最小的子数组 No.239 滑动窗口最大值
No.340 至多包含 K 个不同字符的最长子串 No.567 字符串的排列
No.632 最小区间 No.727 最小窗口子序列
```

# 二分查找的模板

[二分查找详细解读的文章](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)
+ 只要看到 left = mid 的时候，就需要调整成为上取整mid = left + (right-left+1)/2。无条件写上 while (left < right) ，表示退出循环的条件是 left == right，对于返回左右边界就不用思考了，因此此时它们的值相等。
+ 向左取值的方法
```C++
int main(vector<int>& nums, int target){
int len = nums.size();
        if (len == 0) {
            return 0;
        }
int left = 0;
// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是len。
int right = len;
int res = BinarySearch(nums,target,left,right);
return res;
}
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left)/2 ;// 向左取值
            if (check(mid) < target) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [mid + 1, right]，因此把左边界设置到 mid + 1 位置。
                left = mid + 1;
            } else {
	    	// 上面对了以后，不加思考，剩下的区间一定是 [left, mid]，因此左边界向右收缩到 mid 位置
                right = mid;
            }
        }
        return left;
    }
```
+ 向右取值的方法
```C++
int BinarySearch(vector<int>& nums, int target, int left, int right) {
        while (left < right) {
            int mid = left + (right-left+1)/2 ;// 向右取值，这里要+1，防止死循环
            if (check(mid)) {//考虑什么时候不是解，这里要严格用小于号。
                // 下一轮搜索区间是 [left, mid - 1]
                right = mid - 1;
            } else {
	    	// 只有看到 left = mid 的时候，才需要调整成为上取整，记住这一点即可
                left = mid;
            }
        }
        return left;
    }
```
## 硬币

1.题目
```
 硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
 5=5
 5=1+1+1+1+1
```
[此题解析！](https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/)

[背包九讲](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

[注意区分排列数与组合数，两者情况不同](https://leetcode-cn.com/problems/coin-change-2/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/)

2.分析
+ 整体思路
  - dp[i][j] 使用前i种硬币计算j分的表示总数 令coins=[25, 10, 5, 1]
  - dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - j >= k*coins[i]
  - dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]
  - dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]
  - dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]
+ 优化
  - 用一个一维数组来实现转移：我们用数组 dp[0....n]表示，我们在第 i 轮计算之前i−1 轮的答案保存在 dp 数组中。
  - dp[j] 保存的是上一轮的答案 dp[i-1,j]，而 dp[0....j-1] 中保存的是 dp[i,j'],j'∈[0,j−1] 的值，dp[i,j-coins[i]]包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。
+ 实现
注意这里的遍历顺序，**因为是一维数组，且要更新量中的一个为dp[i][j-coins[i]]，因此要保证更新时dp[i]的数据已经不是上一轮dp[i-1]而是这一轮的最新数据，因此要从小往大循环**，
**这和背包问题九讲里的01背包问题不一样，注意区别**
```C++
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};
public:
    int waysToChange(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                dp[i] = (dp[i] + dp[i - coin]) % mod;
            }
        }
        return dp[n];
    }
```
## 零钱兑换

1.题目
```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
2.分析
+ [见解析](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)
+ 一种带备忘录的自上而下的实现（递归）

**注意怎么实现带备忘录 -> 使用带返回参数的递归**
```C++
class Solution {
    vector<int>count;
    int dp(vector<int>& coins, int rem) {
        if (rem < 0) return -1;
        if (rem == 0) return 0;
        if (count[rem - 1] != 0) return count[rem - 1];
        int Min = INT_MAX;
        for (int coin:coins) {
            int res = dp(coins, rem - coin);
            if (res >= 0 && res < Min) {
                Min = res + 1;
            }
        }
        count[rem - 1] = Min == INT_MAX ? -1 : Min;
        return count[rem - 1];
    }
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount < 1) return 0;
        count.resize(amount);
        return dp(coins, amount);
    }
};
```
+ 一种自下而上的迭代算法

**从0开始，使用循环，注意和自上而下使用递归的区别**
```C++
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```
## 数组中的逆序对

1.题目
```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
输入: [7,5,6,4]
输出: 5
```
2.**为了防止两个整型数相加求平均时溢出，我们通常会作如下处理：**
```C++
int i,j;//假设这两个数很大,且j>i
int mid = (i+j)/2;//有可能i+j溢出，不安全
int mid = i+(j-i)/2;更安全的技巧
```

3.**关于copy()函数**

+ copy函数的一些用法：
  - 将数组myints中的七个元素复制到myvector容器中：
  ```C++
  copy (myints, myints+7, myvector.begin());
  ```
  - 将数组myints中的元素向左移动一位:
  ```C++
  copy(myints + 1, myints + 7, myints);
  ```
  - **从标准输入设备读入整数**直到输入的是非整型数据为止;请输入整数序列，按任意非数字键并回车结束输入;输出容器里的所有元素，元素之间用空格隔开:
  ```C++
  #include <algorithm>
  #include <vector>
  #include <iterator>
  #include <string>
  #include<iostream>
  using namespace std；
  int main () 
  {
	 typedef vector<int> IntVector;
	 typedef istream_iterator<int> IstreamItr;
	 typedef ostream_iterator<int> OstreamItr;
	 typedef back_insert_iterator< IntVector > BackInsItr;
	 IntVector myvector;
	 // 从标准输入设备读入整数
	 // 直到输入的是非整型数据为止 请输入整数序列，按任意非数字键并回车结束输入
	 cout << "Please input element：" << endl;
	 copy(IstreamItr(cin), IstreamItr(), BackInsItr(myvector));
	 //输出容器里的所有元素，元素之间用空格隔开
	 cout << "Output : " << endl;
	 copy(myvector.begin(), myvector.end(), OstreamItr(cout, " ")); 
	 cout << endl；
	 return 0;

  }
  ```
+ [copy()函数官方说明文档](https://blog.csdn.net/baidu_41560343/article/details/83095644?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2)
copy函数复制过程是左闭右开的，而且第三个参数是提供另一个有序组的头地址。

4.分析
+ 计算逆序数发生在归并排序的过程中，利用了「排序」以后数组的有序性。
+ 利用「归并排序」计算逆序对，是非常经典的做法；
  - 关键在于「合并两个有序数组」的步骤，利用数组的部分有序性，一下子计算出一个数之前或者之后元素的逆序的个数；
  - 前面「分」的时候什么都不做，「合」的过程中计算「逆序对」的个数；
  - 「排序」的工作是必要的，正是因为「排序」才能在下一轮利用顺序关系加快逆序数的计算，也能避免重复计算；
  - 在代码实现上，只需要在「归并排序」代码的基础上，加上「逆序对」个数的计算，计算公式需要自己在草稿纸上推导。
思想是「分治算法」，所有的「逆序对」来源于 3 个部分：
    - 左边区间的逆序对；
    - 右边区间的逆序对；
    - 横跨两个区间的逆序对。
  - 下面提供两种写法：
1、在第 2 个子区间元素归并回去的时候，计算逆序对的个数；
2、在第 1 个子区间元素归并回去的时候，计算逆序对的个数。
+ 实现
```C++
class Solution {
public:
    int mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r) {
        if (l >= r) {
            return 0;
        }//相当于归并排序时已经拆分到了单个元素，这时直接返回0.

        int mid = (l + r) / 2;
        int inv_count = mergeSort(nums, tmp, l, mid) + mergeSort(nums, tmp, mid + 1, r);//在归并两个有序数组前，首先将这两个数组的逆序对数目进行归并。
        int i = l, j = mid + 1, pos = l;//归并排序的下标处理
        while (i <= mid && j <= r) {//开始对两个有序数组进行归并排序
            if (nums[i] <= nums[j]) {
                tmp[pos] = nums[i];//tmp[]存放归并两个序列后的结果
                ++i;
                inv_count += (j - (mid + 1));//在第 1 个子区间元素归并回去的时候，计算逆序对的个数
            }
            else {
                tmp[pos] = nums[j];
                ++j;
            }
            ++pos;
        }
        for (int k = i; k <= mid; ++k) {//如果第2个子区间元素耗尽，第1个子区间还有元素，则全部拷贝入tmp
            tmp[pos++] = nums[k];
            inv_count += (j - (mid + 1));
        }
        for (int k = j; k <= r; ++k) {//第1个耗尽，第2个子区间还有元素
            tmp[pos++] = nums[k];
        }
        copy(tmp.begin() + l, tmp.begin() + r + 1, nums.begin() + l);//将每一次归并排序结果拷贝到nums中。
        return inv_count;
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp(n);
        return mergeSort(nums, tmp, 0, n - 1);
    }
};
```
[官方题解中的视频讲解非常好！](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/)

[归并算法实现详解](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/)

## 颜色分类

（荷兰旗问题）

1.题目
```
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意:
不能使用代码库中的排序函数来解决这道题。
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
2.快速排序

[详细的解读文章](https://blog.csdn.net/qq_28584889/article/details/88136498)
+ 快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：
  - 1、从数列中取出一个数作为基准数（枢轴，pivot）。 
  - 2、将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。
  - 3、再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。
+ 实现
```C++
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```


3.分析
+ 算法
  - 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.
  - 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.
  - 初始化当前考虑的元素序号 ：curr = 0.
  - While curr <= p2 :
    - 若 nums[curr] = 0 ：交换第 curr个和第 p0 个元素，并将两个指针都向右移。
    - 若 nums[curr] = 2 ：交换第 curr个和第 p2 个元素，并将p2指针左移 。
    - 若 nums[curr] = 1 ：将指针curr右移。
+ 注意，curr 左边全都是0/1的有序序列！
  - curr位置是0时，与左边的0位置交换，因为保证curr左边全是0/1, 所以交换过来的必然是0/1，状态维持住了；
  - curr位置是2时，交换后，curr不能移动，因为一移动，没法保证交换过来的是0/1；所以这里不移动；这时状态也维持住了
  - 只要我们保证curr左边的都是0,1，才移动，那么0都被放到左边，2都被放到右边，中间自然是1了。
+ 实现
```C++
void sortColors(vector<int>& nums) {
    // 对于所有 idx < p0 : nums[idx < p0] = 0
    // curr 是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > p2 : nums[idx > p2] = 2
    int p2 = nums.size() - 1;
    while (curr <= p2) {
      if (nums[curr] == 0) {
        swap(nums[curr++], nums[p0++]);
      }
      else if (nums[curr] == 2) {
        swap(nums[curr], nums[p2--]);
      }
      else curr++;
    }
  }
```
## 全排列

1.题目
```
给定一个 没有重复 数字的序列，返回其所有可能的全排列
```
2.分析

**回溯算法的注意事项：其实就是带撤销的递归算法（使用DFS思想）**
+ 使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；
+ 因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；
+ 深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈。
+ 深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。

3.vector中find函数的使用

需要使用迭代器。
```C++
vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
```
4.实现(**注意emplace_back()和find()的使用**)
```C++
class Solution {
public:
    vector<vector<int>> res;
    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(vector<int>& nums, vector<int>& track){
        // 所有数都填完了
        if (track.size() == nums.size()) {
            res.emplace_back(track);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            vector<int>::iterator itr = find(track.begin(),track.end(),nums[i]); 
            if(itr != track.end()){
                continue;
            }
            track.emplace_back(nums[i]);
            backtrack(nums,track);
            track.pop_back();  
        }
    }
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    vector<vector<int>> permute(vector<int>& nums) {
        if (nums.size() == 0) return {};
	    if (nums.size() == 1) return { {nums[0]} };
        vector<int> track;
        backtrack(nums,track);
        return res;
    }
};
```
5.带备忘录的实现方法
```C++
vector<vector<int> > result;
void func(vector<int> &nums,vector<int> &current, vector<bool>&nums1)
{
	if (current.size() == nums1.size())
		result.push_back(current);
	else
	{
		for (int i = 0; i < nums.size(); i++)
		{
			if (nums1[i])
			{
				current.push_back(nums[i]);
				nums1[i] = false;
				func(nums, current, nums1);
				nums1[i] = true;
				current.pop_back();
			}
		}
	}
}
vector<vector<int>> permute(vector<int>& nums) {
	if (nums.size() == 0)
		return {};
	else if (nums.size() == 1)
		return { {nums[0]} };
	else
	{
		vector<bool> nums1(nums.size(),true);
		vector<int> current;
		func(nums, current, nums1);
		return result;
	}
}
};
```

## 计算右侧小于当前元素的个数

1.题目
```
给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入: [5,2,6,1]
输出: [2,1,1,0] 
```
2.分析
+ 使用归并排序。
  - **本题让我们求 “在一个数组的某个元素的右边，比自己小的元素的个数”，因此，我们可以在 “前有序数组” 的元素出列的时候，数一数 “后有序数组” 已经出列了多少元素，因为这些已经出列的元素都比当前出列的元素要小（或者等于）。**
  - 同理，也可以在后有序数组出列时计算。
+ 我们借助计算 “逆序数” 的思路完成本题，关键在于这里我们只能在 “前有序数组” 出列的时候计算逆序数；
如果题目让我们计算 “nums[i] 左侧小于 nums[i] 的元素的数量” 可以在 “后有序数组” 出列的时候计算逆序数；
+ 实现
```C++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int>count;//保存结果
        vector<pair<int,int> > num;//关联每个数和它的序号
        for(int i =0;i<nums.size();++i)
        {
            count.push_back(0);
            num.push_back(make_pair(nums[i],i));//保存每个数和它在原数组中的序号，以免在排序过程中打乱顺序
        }
        merge_sort(num,count);
        return count;
    }
    
    //归并排序
    void merge_sort(vector<pair<int,int> >& vec, vector<int>& count)
    {
        if(vec.size()<2)
            return;
        
        int mid = vec.size()/2;
        vector<pair<int,int> > sub_vec1;
        vector<pair<int,int> > sub_vec2;
        for(int i =0;i<mid;++i)
            sub_vec1.push_back(vec[i]);
        for(int i =mid;i< vec.size();++i)
            sub_vec2.push_back(vec[i]);
        
        merge_sort(sub_vec1,count);
        merge_sort(sub_vec2,count);
        vec.clear();
        merge(sub_vec1,sub_vec2,vec,count);
    }
    
    //合并两数组
    void merge(vector<pair<int,int> >& sub_vec1,vector<pair<int,int> >& sub_vec2, vector<pair<int,int> >& vec,      vector<int>& count)
    {
        int i =0;
        int j =0;
        while(i < sub_vec1.size() && j < sub_vec2.size())
        {
            if(sub_vec1[i].first <= sub_vec2[j].first )
            {
                vec.push_back(sub_vec1[i]);
                count[sub_vec1[i].second] += j;//这句话和下面注释的地方就是这道题和归并排序的主要不同之处
                i++;
            }else{
                vec.push_back(sub_vec2[j]);
                j++;
            }
        }
    }
};
```
## No.125 验证回文串

1.题目
```
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
输入: "A man, a plan, a canal: Panama"
输出: true
```
2.**C++的几个内置函数**
```
islower(char c) 是否为小写字母
isuppper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小
```
3.实现
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        string tmp;
        for (auto c : s) {
            if (islower(c) || isdigit(c))  tmp += c;
            else if (isupper(c)) tmp += (c + 32);
        }
        int i = 0, j = tmp.size() - 1;
        while (i < j) {
            if (tmp[i] != tmp[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};
```
## No.61 旋转链表

1.题目
```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
```
2.分析
![image](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/images/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.png)

3.实现
```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return NULL;
        int n=0;
        for(auto p=head;p;p=p->next) n++;
        k%=n;
        auto first=head,second=head;
        while(k--){
            first=first->next;
        }
        while(first->next){
            first=first->next;
            second=second->next;
        }
        first->next=head;
        head=second->next;
        second->next=NULL;
        return head;
    }
};
``` 
## No.172 阶乘后的的零
1.题目
```
给定一个整数 n，返回 n! 结果尾数中零的数量。
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
2.分析
+ **对n一直迭代除以5就相当于求n！中5的个数了！！！**
+ 首先肯定不能依赖于把阶乘算出来再去判断有多少个零了，因为阶乘很容易就溢出了，所以先一步一步理一下思路吧。
末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
+ 规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。
最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...
+ 实现
```C++
    int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}

```
## 阶乘函数后K个零

（**二分查找**）

1.题目
```
f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * ... * x，且0! = 1）
例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。
示例 1:
输入:K = 0
输出:5
解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。
```
2.分析
+ 第一个需要注意的地方，二分法查找时需要注意求最大值最小值的边界处理！
  - 这种求等于某个值的**最左边界**的二分查找需要将**等于号放到大于等于的一边**num = l+(r-l)/2;countzero(num)<K；
  - 这种求某个值的**最右边界**的二分查找需要将**等于号放到小于等于的一边**num = l+(r-l+1)/2;countzero(num)<=K;
    - **一定要注意**如果这个(r-l+1)是为了在只剩两个数时，它们中间的数是右边的数。如果不写，根据判断条件（若l=0,r=1），num一直为0，那就一直循环出不来了！
```C++
 long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;//为了在只剩两个数时，它们中间的数是右边的数。
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }

```
+整体实现
```C++
class Solution {
public:
    const long long MAX_N = 1e15;
    long long countzero(long long num){
        long long res=0;
        while(num){
            res += num/5;
            num /= 5;
        }
        return res;
    }
    long long bisearchLeft(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l)/2;
            if(countzero(num)<K){
                l = num+1;
            }
            else{
                r = num;
            }
        }
        return l;
    }
    long long bisearchRight(int K){
        long long l = 0;
        long long r = MAX_N;
        long long num;
        while(l<r){
            num = l+(r-l+1)/2;
            if(countzero(num)<=K){
                l = num;
            }
            else{
                r = num-1;
            }
        }
        return r;
    }
    int preimageSizeFZF(int K) {
        long long left = bisearchLeft(K);
        long long right = bisearchRight(K);
        return (right-left+1);
    }
};
```
## 数组中数字出现的次数

1.题目
```
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```
2.运算符优先级的问题

(make_part&sum) == 0，**这里的括号不能少，因为==的优先级大于&**。
```C++
9	==  !=	等于/不等于
10	&	按位与
11	^	按位异或
12	|	按位或
```

3.分析
+ 考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。
+ 那么这一方法如何扩展到找出两个出现一次的数字。如果我们可以把所有数字分成两组，使得：
  - 两个只出现一次的数字在不同的组中；
  - 相同的数字会被分到相同的组中。
那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。
+ 实现：
```C++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int sum = 0;//求全部数组异或的结果
        for(int n:nums){//由于交换律以及异或的性质，最终结果是两个只出现一次的数字的异或的结果。
            sum ^= n;
        }
        int make_part = 1;//寻找一位作为分组时的比较位，这一位应当在异或结果sum中是1，只有这样
        //才可以让两个只出现一次的数字分在不同组。
        while((make_part&sum) == 0){//根据运算符优先级，一定要加括号
            make_part = make_part<<1;
        }
        int a=0,b=0;
        for(int n:nums){//根据比较位，将数组分为两组
            if(make_part&n){//这里不可以写为make_part&n==1!
                a ^= n;
            }
            else{
                b ^= n;
            }
        }
        return (vector<int>{a,b});
    }
};
```
## 二叉树中的最大路径和

1.题目
```
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
2.分析
+ 本题目涉及**带参数的递归调用（DFS）**
+ 递归思想直接看代码
```C++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL) return 0;
        int res = INT_MIN;//现将值设为允许的最小值（万一树节点里面全是负的）。
        dfs(root,res);//直接调用递归函数，只需要确定res，不需要使用返回值。
        return res;
    }
    int dfs(TreeNode* root,int& res){
        if(root == NULL){//DFS遍历到最底层时返回
            return 0;
        }
        int left = max(0,dfs(root->left,res));//确定当前访问节点的左子树的最大路径和
        //注意要和0比较，因为如果小于0我们可以不选择这一条路径，也就是左子树路径为0.
        int right = max(0,dfs(root->right,res));//确定当前访问节点的右子树的最大路径和
        res = max(res,root->val+right+left);//更新最大路径和，因为是当前节点的最大路径和，一定要包括当前节点
        return root->val+max(right,left);//返回时要因为时返回一条路径，
        //所以只能是当前节点和左/右子树选一条路径和大的返回
    }
};
```
## 山脉数组中查找目标值

1.题目
```
给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。
如果不存在这样的下标 index，就请返回 -1。
何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：
首先，A.length >= 3
其次，在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]
你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：
MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度
```
2.分析
+ 自然地，求解这道题可以分为 3 步：
  - 第 1 步：先找到山顶元素 mountaintop 所在的索引。
  - 第 2 步：在前有序且升序数组中找 target 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；
  - 第 3 步：如果步骤 2 找不到，就在后有序且降序数组中找 target 所在的索引。
+ 注意： 具体编码实现的时候，每一步写一个辅助方法就可以了。这 3 个辅助方法都是二分查找法。
+ 具体实现：
```C++
/**
 * // This is the MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * class MountainArray {
 *   public:
 *     int get(int index);
 *     int length();
 * };
 */

class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int len = mountainArr.length();
	//先寻找山顶元素的索引
        int peak = FindMountainPeak(mountainArr,0,len-1);
        int res;
	//在前面升序的数组中找target，如果存在，就返回它的索引.
        res = SearchForwardArray(target,mountainArr,0,peak);
        if(res != -1){
            return res;
        }
	//如果之前的升序数组中无target，则继续查找后面的降序数组，如果存在就返回索引，否则返回-1.
        return SearchReverseArray(target,mountainArr,peak,len-1);
    }
    //查找山顶元素的索引(关键在于比较mid和mid+1处元素值的大小)
    int FindMountainPeak(MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<mountainArr.get(mid+1)){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
    //在前面升序的数组中找target以及其索引，使用向左取值
    int SearchForwardArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
    //查找后面的降序数组的target以及其索引，也是使用向左取值
     int SearchReverseArray(int target,MountainArray& mountainArr,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(mountainArr.get(mid)>target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        if(mountainArr.get(left)==target){
                return left;
            }
        return -1;
    }
};
```
## 搜索插入位置

1.题目
```
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
输入: [1,3,5,6], 5
输出: 2
```
2.实现

**关注特例判断**
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0){
            return 0;
        }
        // 特判
        if (nums[len - 1] < target) {
            return len;
        }
        int res;
        res = BinarySearch(nums,target,0,len-1);
        return res;

    }
    int BinarySearch(vector<int>& nums,int target,int left,int right){
        while(left<right){
            int mid = left + (right-left)/2;
            if(nums[mid]<target){
                left = mid + 1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
};
```
## 快乐数

1.题目
```
编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 True ；不是，则返回 False 。
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
2.注意unordered_set的使用
```C++
unordered_set<int> res;
while(n != 1 && res.find(n) == res.end()){
```
3.分析

+根据我们的探索，我们猜测会有以下三种可能。
  - 最终会得到 1。
  - 最终会进入循环。
  - 值会越来越大，最后接近无穷大。
+ 对于 3 位数的数字，最大是999，它做各位平方和运算后为243.因此它不可能大于 243。**这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止**。所以我们知道，最坏的情况下，算法可能会在 2243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。**但它不会无限期地进行下去，所以我们排除第三种选择**。
+ 因此，可以使用 哈希Set 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。如果它不在 HashSet 中，我们应该添加它。如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。

4.实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        unordered_set<int> res;
        while(n != 1 && res.find(n) == res.end()){
        res.insert(n);
        n = SquareSum(n);
        }
        if(n==1){
            return true;
        }
        else{
            return false;
        }
    }
};
```
5.快慢指针算法(**双指针思想！**)

+ 通过反复调用 SquareSum(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 SquareSum(n) 函数获得。意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。
+ 我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 SquareSum(n) 函数的嵌套调用）。
  - 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
  - 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。
+ 实现
```C++
class Solution {
public:
    int SquareSum(int n){
        int res= 0;
        while(n){
            int num = n%10;
            n = n/10;
            res += num*num;
        }
        return res;
    }
    bool isHappy(int n) {
        int SlowRunner = n;
        int FastRunner = SquareSum(n);
        while(FastRunner != 1 && FastRunner != SlowRunner){
        SlowRunner = SquareSum(SlowRunner);
        FastRunner = SquareSum(SquareSum(FastRunner));
        }
        return FastRunner == 1; 
    }
};
```
## 排序数组

1.题目
```
给你一个整数数组 nums，请你将该数组升序排列。
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```
2.分析
+ 最简单的实现：调用sort函数
```C++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        if(nums.size()==0){
            return {};
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```
## 用队列实现栈

1.题目
```
使用队列实现栈的下列操作：
push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
```
2.分析
+ 维护队列使其队头对应栈的栈顶，队尾对应栈的栈底。则需要在每次在队列尾部加入元素之后将原本就有的res.size() - 1个元素从头取出放回尾部以使队头对应栈顶，队尾对应栈底。
+ 实现
```C++
 queue<int> res;
    /** Initialize your data structure here. */
    MyStack() = default;   
    /** Push element x onto stack. */
    void push(int x) {
        res.push(x);
        for(int i=0;i<res.size()-1;i++){
            res.push(res.front());
            res.pop();
        }
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int tmp = res.front();
        res.pop();
        return tmp;
    }
    /** Get the top element. */
    int top() {
        return res.front();
    }  
    /** Returns whether the stack is empty. */
    bool empty() {
        return res.empty();
    }
```
## 用栈实现队列

1.题目
```
使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
```
2.分析
+ 用两个栈实现！**一定要注意在出栈时栈的大小不能作循环条件！需要使用栈是否为空作为判断依据**
```c++
stack<int> res;
stack<int> temp;
// for(int i=0;i<res.size();i++){
//     temp.push(res.top());
//     res.pop();
// }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
 while(!res.empty()){
     temp.push(res.top());
     res.pop();
 }
```
+ 实现
```c++
stack<int> res;
    /** Initialize your data structure here. */
    MyQueue() = default;
    
    /** Push element x to the back of queue. */
    void push(int x) {
        stack<int> temp;
        // for(int i=0;i<res.size();i++){
        //     temp.push(res.top());
        //     res.pop();
        // }存在的问题：每次res.pop()后res的大小都改变了，无法让res.size()保持原始大小！
        while(!res.empty()){
            temp.push(res.top());
            res.pop();
        }
        res.push(x);
    //     for(int j=0;j<temp.size();j++){
    //         res.push(temp.top());
    //         temp.pop();
    //     }
        while(!temp.empty()){
            res.push(temp.top());
            temp.pop();
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        int tmp = res.top();
        res.pop();
        return tmp;
    }
    
    /** Get the front element. */
    int peek() {
        return res.top();
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return res.empty();
    }
```
## 无重复字符的最长子串

1. 题目
```
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
2.分析
+ 双指针、滑窗优化算法：
  - 创建一个左指针和一个右指针均指向s[0]，左指针先不动，移动右指针并计算子串长度；当出现重复字符时，向右移动左指针直至没有重复字符。子串存储在unordered_set中。
  - 部分实现
  ```C++
  for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
  ```
  - 这个while是滑窗（双指针）算法的精髓，在hashset中一直存在右指针指向的值时，一直将左指针向右移动，并删除hashset中左指针对应的值，这样做是合理的，不影响最长子串的确定。
+ 整体实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.length();
        if(len == 0) return 0;
        unordered_set<char> uset;//存储不包含重复字符的子串
        int res = 0;
        int left = 0;//滑窗中的左指针
        for(int i=0;i<len;++i){//i相当于右指针
            while(uset.find(s[i]) != uset.end() ){
                uset.erase(s[left]);
                left++;
            }
            uset.insert(s[i]);
            res = max(res,i-left+1);
        }
        return res;
    }
};
```
3.动态规划算法（麻烦一些）
+ dp[i]表示以第i个字符结尾的无重复字符子串的长度。比如 abcbc :
```C++
dp[0] = 1;  "a"
dp[1] = 2;  "ab"
dp[2] = 3;  "abc"
dp[3] = 2;  "cb"
dp[4] = 2;  "bc"
```
+ 初始值：对于第一个字符，dp[0] = 1
+ 状态转移：对于第i个字符，如果在dp[i-1]所代表的子串中出现，那么从所出现的位置j的下一个位置到i，构成了以i结尾的不重复子串。即dp[i] = i-j;
如果第i个字符不在前面的dp[i-1]子串中出现，那么i-1子串加上i字符构成了i子串，因此 dp[i] = dp[i-1]+1。那么需要担心j位置后又出现了字符i吗？不需要，因为前面的子串本身就是不重复的，不可能存在两个字符i。
+ 最大值： 返回 max(dp[i])。
+ 空间优化：由于只需要知道前一个子串的长度，因此仅需记录 lastLen。
+ 实现
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int size = (int)s.size();
        if(size==0){
            return 0;
        } 
        int lastLen = 1;
        int max = 1;
        int curLen = 0;
        for(int i=1; i<size; ++i){
            curLen = 0;
            for(int j=i-lastLen; j<=i-1; ++j){
                if(s[j]==s[i]){
                    curLen = i-j;
                    break;
                }
            }
            if(curLen==0){
                curLen = lastLen + 1;
            }
            
            if(curLen>max){
                max = curLen;
            }

            lastLen = curLen;
        }
        return max;
    }
};
```
## 串联所有单词的子串

1.题目
```

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
输入：
  s = "barfoothefoobarman",
  words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
```
2.一些技巧

+ substr()的使用：两个参数分别为字符串中子串的起始和终止位置。
```C++
 string temp_str = s.substr(j,word_size);
```
+ unordered_map键的赋值语句:
```C++
for(auto word:words){
       m1[word]++;
   } 
```


3.分析

+ 用两个 HashMap 来解决。首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（**因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他**）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。
  - 因为单词的长度 len 是固定的，所以可以将一个单词看成一个单元
  - 对单词使用滑动窗口，单元间的步长就是 len
  - 在 0 - len 的范围内，每一个都作为滑动窗口的起点，滑动 len 次，即可覆盖所有字符串的各种组合
+ 实现
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        if(words.size() == 0)//判断words为空,因为下面用到了words[0]
            return res;
        
        int word_size = words[0].size();
        int word_num = words.size();
        
        unordered_map<string,int> m1;//构造hashmap
        for(int i=0;i<word_num;i++){
            m1[words[i]]++;
        }
        //注意也可以用auto修饰符
        // for(auto word:words){
        //     m1[word]++;
        // }    
        unordered_map<string,int> m2;//统计滑窗中的单词
        for(int i=0; (i + word_size * word_num) <= s.size() ; i++){//截取的s符合题意
            int j = 0;
            for(j=i;j < (i + word_size * word_num) ; j=j+word_size){//分段判断
                string temp_str = s.substr(j,word_size);
                if(m1[temp_str] == 0){//m1中没有截取的串，直接跳出
                    break;
                }else{
                    m2[temp_str]++;
                    if(m1[temp_str] < m2[temp_str])//滑窗中单词出现次数超过了m1，也跳出
                        break;
                }
            }
            
            if(j == (i + word_size * word_num))//每一段都符合，则加入答案
                ret.push_back(i);
            
            m2.clear();//清空m2,开始下一个滑窗
        }
        return res;
    }
};

```
## 组合总数

1.题目
```

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```
2.分析

[这篇解答很棒](https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)
+ 还是那个回溯算法框架
```C++
void backtrack(路径，选择列表){
    if(满足结束条件){
        result.add(结果);
    }
    for(选择：选择列表){
        做出选择;
        backtrack(路径，选择列表);
        撤销选择;
    }
}
```
+ 以 target 为根结点，每一个分支做减法；
  - 减到 0 或者负数的时候，到了叶子结点；
  - 减到 0 的时候结算，这里 “结算” 的意思是添加到结果集；
  - 从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。
+ **剪枝去重复**
  - 在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点以本层减去的数作为搜索起点开始搜索；
  - 在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;// 从根结点到任意结点的选择路径
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(0,candidates,target);
        return res;
    }

    void dfs(int start, vector<int>& candidates, int target ){
        if(target == 0){
            res.push_back(path);
            return;
        }
        for(int i=start;i<candidates.size();i++){
            //因为candidates排序了，当前的值都比target大，之后的一定也更大，所以直接返回
            if(target - candidates[i] < 0) return;
            path.push_back(candidates[i]);//做选择
            //注意，剪枝的核心在于起点搜索下标为i,根据深度优先树，比i小的下标的值，之前都已经深度遍历多了
            dfs(i,candidates,target-candidates[i]);
            path.pop_back();//撤销选择
        }
    }
};
```
## 组合总和

1.题目
```

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```
2.分析
+ 依然是回溯算法+剪枝，注意和NO.39比较
+ 实现
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        if(candidates.size()==0) return {};
        dfs(candidates,target,0);
        return res;
    }
    void dfs(vector<int>& candidates, int target, int start){
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i=start;i<candidates.size();i++){
            if(target-candidates[i]<0){
                return;
            } 
            if(i>start&&candidates[i] == candidates[i-1]) continue;//仔细思考，关键的剪枝判断！
            path.push_back(candidates[i]);
            dfs(candidates,target-candidates[i],i+1);
            path.pop_back();
        }
    }
};
```
## 跳跃游戏II

**关注贪心算法！**

1.题目
```
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```
2.分析

+ 自己的递归算法会超时，递归条件如果也要贪心算法的话，就没必要递归了。
+ 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。
  - 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。
  - 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。
+ 实现
```C++
int jump(vector<int> &nums){
        int ans = 0;
        int start = 0;
        int end = 1;
        while (end < nums.size()){
            int maxPos = 0;
            for (int i = start; i < end; i++){
                // 能跳到最远的距离
                maxPos = max(maxPos, i + nums[i]);
            }
            start = end;      // 下一次起跳点范围开始的格子
            end = maxPos + 1; // 下一次起跳点范围结束的格子
            ans++;            // 跳跃次数
        }
        return ans;
    } 
```

## 和为s的连续正数序列

1.题目
```
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

输入：target = 9
输出：[[2,3,4],[4,5]]
```
2.分析

+ 要用滑动窗口解这道题，我们要回答两个问题：第一个问题，窗口何时扩大，何时缩小？第二个问题，滑动窗口能找到全部的解？
+ 对于第一个问题：
  - 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动。
  - 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动。
  - 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为[i,j]，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。
+ 第二个证明是显然的，因为序列是等差单增的。
+ 实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。
+ 实现：
```C++
vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>> res;
        int left = 1;//左指针（左边界）
        int right = 1;//右指针（右边界）
        int sum = 0;
        while(left<=target/2){//题目要求一个序列至少包含两个数，所以左滑窗到target一半即可。
            if(sum<target){
                sum += right;
                right++;
            }
            else if(sum>target){
                sum -=left;
                left++;
            }
            else{//滑窗内和为target
                vector<int> temp;
                for(int i=left;i<right;i++){
                    temp.push_back(i);
                }
                res.push_back(temp);
                sum -= left;//向右移动左指针，注意和下一句顺序不能反。
                left++;   
            }
        }
        return res;
    }
```
## 验证二叉搜索树

**关注中序遍历二叉树的实现！！，关注此题递归函数的退出条件！！**

1.题目
```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

输入:
    2
   / \
  1   3
输出: true
```
2.分析

+ 由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。
+ 这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。
+ 那么根据二叉搜索树的性质，在递归调用左子树时，需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。
+ 函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。
+ 实现
```C++
 bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;//关注递归函数返回为真的判断！即遍历到底nullptr也没出错！！
        if (root -> val <= lower || root -> val >= upper) return false;
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);//关注起始时的最大最小值
    }
```
3.中序遍历方法
```C++
  //关注栈的使用
  bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stack;
        long long inorder = (long long)INT_MIN - 1;

        while (!stack.empty() || root != nullptr) {
            while (root != nullptr) {
                stack.push(root);
                root = root -> left;
            }
            root = stack.top();
            stack.pop();
            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root -> val <= inorder) return false;
            inorder = root -> val;
            root = root -> right;
        }
        return true;
    }

```
或者
```C++
class Solution {
public :
    long pre = MIN_LONG;
    boolean isValidBST(TreeNode* root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root->left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root->val <= pre) {
            return false;
        }
        pre = root->val;
        // 访问右子树
        return isValidBST(root->right);
    }
}
```
## 最低票价

1.题目
```
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
一张为期一天的通行证售价为 costs[0] 美元；
一张为期七天的通行证售价为 costs[1] 美元；
一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。
```
2.**需要正确地在类中初始化vector成员变量**

+ **错误方法**
```C++
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
```
+ **正确方法**
```C++
//C++11后
class Foo(){
public:
    // 法一
    vector<string> name = vector<string>(5);
    // 法二
    vector<int> val{vector<int>(5,0)};
}
//C++11之前
class Foo {
public:
    vector<string> name;
    vector<int> val;
    Foo() : name(5), val(5,0) {}
};
```


3.分析

+ 用 dp(i) 来表示从第 i 天开始到一年的结束，需要花的钱。考虑到一张通行证可以让我们在「接下来」的若干天进行旅行，所以**「从后往前」**倒着进行动态规划。**代码中的体现就是主函数中dp函数从dp(1)开始**
+ 对于一年中的任意一天：
  - 如果这一天不是必须出行的日期，可以贪心地选择不买。这是因为如果今天不用出行，那么也不必购买通行证，并且通行证越晚买越好。所以有 dp(i)=dp(i+1)；
  - 如果这一天是必须出行的日期，可以选择买 1，7 或 30 天的通行证。若购买了 j 天的通行证，那么接下来的 j−1 天，都不再需要购买通行证，只需要考虑第 i+j 天及以后即可。因此有： dp(i)=min{cost(j)+dp(i+j)},j∈{1,7,30}. 其中 cost(j) 表示 j 天通行证的价格;
+ 由于我们是倒着进行动态规划的，因此我们可以使用记忆化搜索，减少代码的编写难度。我们使用一个长度为 366 的数组（因为天数是[1,365]，而数组的下标是从 0 开始的）存储所有的动态规划结果，这样所有的 dp(i) 只会被计算一次（和普通的动态规划相同），时间复杂度不会增大。
+ 实现
```C++
unordered_set<int> travaldays;//保存旅行日期
    vector<int> memo;//类成员不能直接初始化，要在成员函数里初始化！
    vector<int> costs;//全局声明，这样dp函数就可以直接用了，不用传参costs[]。
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        memo.resize(366,-1);//记录从任意一天开始旅行的最小花费
        this->costs = costs;
        for(auto tarvelday : days){
            travaldays.insert(tarvelday);
        }
        int result = dp(1);//从后往前递归和动态规划
        return result;
    }
    int dp(int startday){
        if(startday > 365){
            return 0;
        }
        if(memo[startday] != -1){
            return memo[startday];
        }
        if(!travaldays.count(startday)){
            //注意这里是dp(startday+1)不是memo[startday+1],因为是从后往前动态规划，要先把后面动态规划的值求出来
            memo[startday] = dp(startday+1);
        }
        else{
            memo[startday] = min(dp(startday+1)+costs[0],min(dp(startday+7)+costs[1],dp(startday+30)+costs[2]));
        }
        return memo[startday];
    }
```
## 水壶问题

1.题目
```
有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？
如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。
你允许：
装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空

输入: x = 3, y = 5, z = 4
输出: True
```
2.**lambda函数与表达式**：

+ C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下：
```C++
[capture](parameters) mutable ->return-type{statement};
//例如
[](int x, int y){ return x < y ; };
[](int x, int y) -> int { int z = x + y; return z + x; };
```
+ [capture]：捕捉列表。捕捉列表总是出现在 lambda 表达式的开始处。事实上，[] 是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数。捕捉列表能够捕捉上下文中的变量供 lambda 函数使用。
```
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```
+ (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号 () 一起省略。
+ mutable：mutable 修饰符。默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。
+ ->return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号 -> 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。
+ {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

3.**decltype 关键字**

+ 官方说明
```
decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto是有一些区别的。
decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，
返回该表达式的类型,而且decltype并不会对表达式进行求值。

decltype关键字用于查询表达式的类型，并不会对表达式进行求值。
decltype的作用是获得一个变量或表达式的类型。
decltype 不会执行表达式而auto会，decltype仅仅推论一下表达式的类型。
```
+ 对于decltype(e)而言，其判别结果受以下条件的影响：
  - 如果e是一个标识符或者类成员的访问表达式，则decltype(e)就是e所代表的实体的类型。如果没有这种类型或者e是一个重载函数集，那么程序是错误的；
  - 如果e是一个函数调用或者一个重载操作符调用(忽略e外面的括号)，那么decltype(e)就是该函数的返回类型；
  - 如果e不属于以上所述的情况，则假设e的类型是 T：当e是一个左值时，decltype(e)就是T&；否则(e是一个右值)，decltype(e)是T。
+ 一些例子：
```C++
#include "decltype.hpp"
#include <iostream>
#include <string>
#include <utility>
#include <iomanip>
 
//////////////////////////////////////////////
// reference: http://en.cppreference.com/w/cpp/language/decltype
struct A { double x; };
const A* a = new A{ 0 };
 
decltype(a->x) y;       // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
 
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u); // return type depends on template parameters
 
int test_decltype1()
{
	int i = 33;
	decltype(i) j = i * 2;
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	auto f = [](int a, int b) -> int
	{
		return a * b;
	};
 
	decltype(f) g = f; // the type of a lambda function is unique and unnamed
	i = f(2, 2);
	j = g(3, 3);
 
	std::cout << "i = " << i << ", " << "j = " << j << '\n';
	return 0;
}
```
4.分析

+ 在任意一个时刻，此问题的状态可以由两个数字决定：X 壶中的水量，以及 Y 壶中的水量。在任意一个时刻，我们可以且仅可以采取以下几种操作：
  - 把 X 壶的水灌进 Y 壶，直至灌满或倒空；
  - 把 Y 壶的水灌进 X 壶，直至灌满或倒空；
  - 把 X 壶灌满；
  - 把 Y 壶灌满；
  - 把 X 壶倒空；
  - 把 Y 壶倒空。
+ 因此，本题可以使用深度优先搜索来解决。搜索中的每一步以 remain_x, remain_y 作为状态，即表示 X 壶和 Y 壶中的水量。在每一步搜索时，我们会依次尝试所有的操作，递归地搜索下去。这可能会导致我们陷入无止境的递归，因此我们还需要使用一个哈希结合（HashSet）存储所有已经搜索过的 remain_x, remain_y 状态，保证每个状态至多只被搜索一次。
+ 实现
```C++
using PII = pair<int, int>;

class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        stack<PII> stk;
        stk.emplace(0, 0);
        auto hash_function = [](const PII& o) {return hash<int>()(o.first) ^ hash<int>()(o.second);};
        unordered_set<PII, decltype(hash_function)> seen(0, hash_function);
        while (!stk.empty()) {
            if (seen.count(stk.top())) {
                stk.pop();
                continue;
            }
            seen.emplace(stk.top());
            
            auto [remain_x, remain_y] = stk.top();
            stk.pop();
            if (remain_x == z || remain_y == z || remain_x + remain_y == z) {
                return true;
            }
            // 把 X 壶灌满。
            stk.emplace(x, remain_y);
            // 把 Y 壶灌满。
            stk.emplace(remain_x, y);
            // 把 X 壶倒空。
            stk.emplace(0, remain_y);
            // 把 Y 壶倒空。
            stk.emplace(remain_x, 0);
            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stk.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));
            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stk.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));
        }
        return false;
    }
};
```
5.数学方法

+ 我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得ax+by=z
  - 而只要满足 z≤x+y，且这样的 a, ba,b 存在，那么我们的目标就是可以达成的。这是因为：
  - 若 a≥0,b≥0，那么显然可以达成目标。
  - 若 a<0，那么可以进行以下操作：
    - 往 y 壶倒水；
    - 把 y 壶的水倒入 x 壶；
    - 如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。
  - 重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。
  - 若 b<0，方法同上，x 与 y 互换。
+ 根据贝祖定理，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。
+ 实现
```C++
    bool canMeasureWater(int x, int y, int z) {
        if (x + y < z) return false;
        if (x == 0 || y == 0) return z == 0 || x + y == z;
        return z % gcd(x, y) == 0;
    }
```
## 另一个树的子树

1.题目
```
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true
```
2.方法一（dfs+递归）

+ 一个树是另一个树的子树，那么即有：
  - 要么这两个树相等
  - 要么这个树是左树的子树
  - 要么这个树是右树的子树
+ 基于dfs和递归对每一个节点进行判断，**注意dfs遍历二叉树，就是前序遍历，参考No.98/105**
+ 实现
```C++
    bool isSametree(TreeNode* s, TreeNode* t){//判断两棵树是否相等
        if(s == nullptr&&t == nullptr){
            return true;//递归的返回条件，均空自然之前全相等，所以返回真。
        }
        return s&&t
                && s->val == t->val
                && isSametree(s->left,t->left)//递归判断
                && isSametree(s->right,t->right);
    }
    bool isSubtree(TreeNode* s, TreeNode* t) {//判断t是否是s的子树
        if(s == nullptr&&t == nullptr){
            return true;
        }
        if(s == nullptr&&t != nullptr){
            return false;
        }
        return isSametree(s,t)
            || isSubtree(s->left,t)//dfs
            || isSubtree(s->right,t);     
    }
```
3.方法二

[方法介绍](https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/)
+ **一棵子树上的点在 DFS 序列（即前序遍历）中是连续的**。我们可以确定解决这个问题的方向就是：把 s 和 t 先转换成 DFS 序，然后看 t 的 DFS 序是否是 s 的 DFS 序的「子串」。

+ 存在的问题： 假设 s 由两个点组成，1 是根，2 是 1 的左孩子；t 也由两个点组成，1 是根，2 是 1 的右孩子。这样一来 s 和 t 的 DFS 序相同，可是 t 并不是 s 的某一棵子树。由此可见「s 的 DFS 序包含 t 的 DFS 序」是「t 是 s 子树」的 必要不充分条件，所以单纯这样做是不正确的。

+ 为了解决这个问题，我们可以引入两个空值 lNull 和 rNull，当一个节点的左孩子或者右孩子为空的时候，就插入这两个空值，这样 DFS 序列就唯一对应一棵树。处理完之后，就可以通过判断 「s 的 DFS 序包含 t 的 DFS 序」来判断答案。

+ 在判断「s 的 DFS 序包含 t 的 DFS 序」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp 算法，在使用 Rabin-Karp 算法的时候，要注意串中可能有负值。
+实现
```C++
    vector <int> sOrder, tOrder;
    int maxElement, lNull, rNull;

    void getMaxElement(TreeNode *o) {
        if (!o) return;
        maxElement = max(maxElement, o->val);
        getMaxElement(o->left);
        getMaxElement(o->right);
    }

    void getDfsOrder(TreeNode *o, vector <int> &tar) {
        if (!o) return;
        tar.push_back(o->val);
        if (o->left) getDfsOrder(o->left, tar);
        else tar.push_back(lNull);
        if (o->right) getDfsOrder(o->right, tar);
        else tar.push_back(rNull);
    }

    bool kmp() {
        int sLen = sOrder.size(), tLen = tOrder.size();
        vector <int> fail(tOrder.size(), -1);
        for (int i = 1, j = -1; i < tLen; ++i) {
            while (j != -1 && tOrder[i] != tOrder[j + 1]) j = fail[j];
            if (tOrder[i] == tOrder[j + 1]) ++j;
            fail[i] = j;
        }
        for (int i = 0, j = -1; i < sLen; ++i) {
            while (j != -1 && sOrder[i] != tOrder[j + 1]) j = fail[j];
            if (sOrder[i] == tOrder[j + 1]) ++j;
            if (j == tLen - 1) return true;
        }
        return false;
    }

    bool isSubtree(TreeNode* s, TreeNode* t) {
        maxElement = INT_MIN;
        getMaxElement(s);
        getMaxElement(t);
        lNull = maxElement + 1;
        rNull = maxElement + 2;

        getDfsOrder(s, sOrder);
        getDfsOrder(t, tOrder);

        return kmp();
    }
```
## 单词的压缩编码

1.题目
```
给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。
例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。
对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。
那么成功对给定单词列表进行编码的最小字符串长度是多少呢？
输入: words = ["time", "me", "bell"]
输出: 10
说明: S = "time#bell#" ， indexes = [0, 2, 5] 。
```
2.substr函数用法

+ 用途：一种构造string的方法
+ 形式：s.substr(pos, n)
+ 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）
+ 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾

3.**字典树**

+ 字典树又名前缀树，Trie树，是一种存储大量字符串的树形数据结构，相比于HashMap存储，在存储单词（和语种无关，任意语言都可以）的场景上，节省了大量的内存空间。
+ 根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。
+ 用字典树去做的题目，明显特征就是需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀。 
  - **用后缀也可以的原因是因为把单词倒着插入，就可以搜后缀了**

4.方法一
+ 如果单词 X 是 Y 的后缀，那么单词 X 就不需要考虑了，因为编码 Y 的时候就同时将 X 编码了。例如，如果 words 中同时有 "me" 和 "time"，我们就可以在不改变答案的情况下不考虑 "me"。
+ 如果单词 Y 不在任何别的单词 X 的后缀中出现，那么 Y 一定是编码字符串的一部分。
+ 因此，目标就是保留所有不是其他单词后缀的单词，最后的结果就是这些单词长度加一的总和，因为每个单词编码后后面还需要跟一个 # 符号。
+ 实现
```C++
    int minimumLengthEncoding(vector<string>& words) {
        unordered_set<string> good(words.begin(), words.end());
        for (const string& word: words) {
            for (int k = 1; k < word.size(); ++k) {
                good.erase(word.substr(k));
            }
        }

        int ans = 0;
        for (const string& word: good) {
            ans += word.size() + 1;
        }
        return ans;
    }
```
5.方法二
+ 去找到是否不同的单词具有相同的后缀，我们可以将其反序之后插入字典树中。例如，我们有 "time" 和 "me"，可以将 "emit" 和 "em" 插入字典树中。
+ 实现
```C++
class TrieNode{//定义一个字典树
    TrieNode* children[26];//指针的数组，每个父节点最多有26个子节点
public:
    int count;
    TrieNode() {//构造函数初始化，构造父节点和它的26个子节点
        for (int i = 0; i < 26; ++i) children[i] = NULL;
        count = 0;
    }
    //将字母转化为数字，如果是新字母，就创建一个新的子树。并加1表示这个节点不是最后一个节点，也就是叶子结点。
    TrieNode* get(char c) {
        if (children[c - 'a'] == NULL) {
            children[c - 'a'] = new TrieNode();
            count++;
        }
        return children[c - 'a'];
    }
};
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        TrieNode* trie = new TrieNode();
        unordered_map<TrieNode*, int> nodes;

        for (int i = 0; i < (int)words.size(); ++i) {
            string word = words[i];
            TrieNode* cur = trie;//字典树
            for (int j = word.length() - 1; j >= 0; --j)//倒序插入
                cur = cur->get(word[j]);
            nodes[cur] = i;
        }

        int ans = 0;
        for (auto& [node, idx] : nodes) {
	//意味着这个节点是个叶子，cur保存着每个word对应的最后一个节点，当它是一个叶子时，我们就该累加这个word的长度+1.
            if (node->count == 0) {
                ans += words[idx].length() + 1;
            }
        }
        return ans;
    }
};
```
## 最大正方形

1.题目
```
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4
```
2.方法一（**动态规划**）

+ 我们用 dp(i,j) 表示以 (i,j) 为右下顶点，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。
+ 对于每个位置 (i,j)，检查在矩阵中该位置的值：
  - 如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；
  - 如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，**这类似于木桶短板效应**。状态转移方程如下：
  ```
  dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1
  ```
+ 实现
```C++
 int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size()==0) return 0;
        int maxSide = 0;
        int rows = matrix.size();
        int cols = matrix[0].size();
        //dp[i][j]表示以(i,j)为正方形右下角顶点的正方形的最大边长
        vector<vector<int>> dp(rows,vector<int>(cols));
        //将边界中为1的位置dp设为1
        for(int i=0;i<rows;i++){
            if(matrix[i][0] == '1'){
                dp[i][0] = 1;
                maxSide = 1;
            }
        }
        for(int i=0;i<cols;i++){
            if(matrix[0][i] == '1'){
                dp[0][i] = 1;
                maxSide = 1;
            }
        }
        for(int i=1;i<rows;i++){
            for(int j=1;j<cols;j++){
                if(matrix[i][j] == '1'){//为'0'的情况不用写，因为已经dp在初始化时就全为0了。
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;;
                }
                maxSide = max(maxSide,dp[i][j]);
            }
        }
        return maxSide*maxSide;
    }
```
3.方法二（暴力解法）

+ 遍历矩阵中的每个元素，每次遇到 1，则将该元素作为正方形的左上角；
+ 确定正方形的左上角后，根据左上角所在的行和列计算可能的最大正方形的边长（正方形的范围不能超出矩阵的行数和列数），在该边长范围内寻找只包含 1 的最大正方形；
+ 每次在下方新增一行以及在右方新增一列，判断新增的行和列是否满足所有元素都是 1。
+ 实现
```C++
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    // 遇到一个 1 作为正方形的左上角
                    maxSide = max(maxSide, 1);
                    // 计算可能的最大正方形边长
                    int currentMaxSide = min(rows - i, columns - j);
                    for (int k = 1; k < currentMaxSide; k++) {
                        // 判断新增的一行一列是否均为 1
                        bool flag = true;
                        if (matrix[i + k][j + k] == '0') {
                            break;
                        }
                        for (int m = 0; m < k; m++) {
                            if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') {
                                flag = false;
                                break;
                            }
                        }
                        if (flag) {
                            maxSide = max(maxSide, k + 1);
                        } else {
                            break;
                        }
                    }
                }
            }
        }
        int maxSquare = maxSide * maxSide;
        return maxSquare;
    }
```
## 腐烂的橘子

1.题目
```
在给定的网格中，每个单元格可以有以下三个值之一：
值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。
返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。
```
2.**按位取反的问题**

+ [原码、反码、补码的详细解读](https://blog.csdn.net/wo17fang/article/details/52241682)**补码的定义：**所有的正整数的补码是他本身，所有的负数的补码是对取绝对值后的二进制码取反，加一。
```
[+1] = [00000001]原码 = [00000001]反码 = [00000001]补码

[-1] = [10000001]原码 = [11111110]反码 = [11111111]补码
```
+ 无论是以进制表示还是整数形式赋值给变量，都要根据变量相应的数据类型，表示为补码的形式存储进计算机内存中；
+ 无论是在做数据类型强制转换（内存存储形式没有改变，这一点可以通过查看Memory得到）还是做位运算的时候，实际上都是对  
内存中存储的数进行的操作（也可以查看Memory得到），至于呈现的时候就是根据设定的数据类型把内存中存储的二进制数字进行相应规则的呈现即可 
+ 例子：
```
8按位取反后的结果(~8)
(1)8的二进制
00000000 00000000 00000000 00001000
(2)取反之后
11111111 11111111 11111111 11110111
(3)由于它是补码，那么左边第一位是符号位，而符号位是1，数值为负，则数的绝对值为-1后，剩下的数位按位取反
00000000 00000000 00000000 00001001 
(4)为-9
```
3.**if的执行条件**

+ C++ 中 if 语句的语法：
```C++
if(boolean_expression)
{
   // 如果布尔表达式为真将执行的语句
}
```
+ 如果布尔表达式为 true，则 if 语句内的代码块将被执行。如果布尔表达式为 false，则 if 语句结束后的第一组代码（闭括号后）将被执行。**C语言把任何非零和非空的值假定为 true**，把零或 null 假定为 false。 **因此下面的例子可以正常执行if：**
```C++
if(-3){
cout<<success<<endl;
}
```
4. 第一种BFS
+ 观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。
+ 假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(**我们令其为超级源点**)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 −1 ，那么按照广度优先搜索的算法，下一分钟也就是第 0 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。
+ 那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x][y] 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。（有点动态规划那味）
+ 实现
```C++
int cnt;
    int dis[10][10];
    int dir_x[4]={0, 1, 0, -1};//辅助定位即将被腐烂的橘子的横坐标
    int dir_y[4]={1, 0, -1, 0};//辅助定位即将被腐烂的橘子的纵坐标，对应构成腐烂橘子的四个污染方向
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int,int>> Q;//BFS算法标准实现，先进先出，按照腐烂时间顺序保存被腐烂的橘子
        memset(dis, -1, sizeof(dis));
        cnt = 0;
        int n=(int)grid.size(), m=(int)grid[0].size(), ans = 0;
        for (int i = 0; i < n; ++i){
            for (int j = 0; j < m; ++j){
                if (grid[i][j] == 2){
                    Q.push(make_pair(i, j));
                    dis[i][j] = 0;//将一开始就腐烂的橘子当做是被超级源点腐烂的，此时腐烂时间为0.
                }
                else if (grid[i][j] == 1) cnt += 1;
            }
        }
        while (!Q.empty()){
            pair<int,int> x = Q.front();
            Q.pop();
            for (int i = 0; i < 4; ++i){//在腐烂的橘子的四个方向进行移动污染
                int tx = x.first + dir_x[i];
                int ty = x.second + dir_y[i];
                //首先对橘子是否在网给内进行判断，之后判断这个网格内有没有橘子（有橘子才可以污染），
		//同时判断这个橘子是否是没被污染的橘子（如果已经腐烂了的话就不会继续更新腐烂时间了）
                if (tx < 0|| tx >= n || ty < 0|| ty >= m|| dis[tx][ty] >= 0 || !grid[tx][ty]) continue;
                dis[tx][ty] = dis[x.first][x.second] + 1;//被它周围的橘子污染了，腐烂时间+1.
                Q.push(make_pair(tx, ty));//加入队列
                if (grid[tx][ty] == 1){
                    cnt -= 1;//新鲜橘子-1
                    ans = dis[tx][ty];//记录腐烂时间
                    if (!cnt) break;
                }
            }
        }
        return cnt ? -1 : ans;//如果新鲜橘子不为0.那么污染失败返回-1；否则返回污染时间
    }
```
5. 第二种BFS
+ 用正常的 BFS 模板来求最短路径的话，这个队列中第 1 波腐烂的橘子和第 2 波腐烂的橘子的结点会紧挨在一起，无法区分。因此，我们需要稍微修改一下代码，在每一层遍历开始前，记录队列中的结点数量 n ，然后一口气处理完这一层的 n 个结点。

+ 实现
```C++
int orangesRotting(vector<vector<int>>& grid) {
        int min = 0, fresh = 0;
        queue<pair<int, int>> q;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++)
                if(grid[i][j] == 1) fresh++;
                else if(grid[i][j] == 2) q.push({i, j});
        }
        vector<pair<int, int>> dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
        while(!q.empty()) {
            int n = q.size();//标记队列内腐烂橘子个数
            bool rotten = false;//标记这一轮污染是否污染到了新的新鲜橘子
            for(int i = 0; i < n; i++) {
                auto x = q.front();
                q.pop();
                for(auto cur: dirs) {
                    int i = x.first + cur.first;
                    int j = x.second + cur.second;
                    if(i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1) {
                        grid[i][j] = 2;
                        q.push({i, j});
                        fresh--;
                        rotten = true;
                    }
                }
            }
            if(rotten) min++;
        } 
        return fresh ? -1 : min;
    }

```
## x的平方根

1.题目
```
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

输入: 4
输出: 2
```
2.分析
+ 很明显的可以用二分查找算法，这里列出**我自己的实现和答案的区别**：
  - 其实不需要特别判断0~3的情况，然后缩小搜索上界为x/2，因为搜索上界缩小一半其实也只节省了一次二分查找，对计算复杂度影响不大。
  - 注意ans = mid,left = mid + 1这个操作，这样做可以省去最后判断结果要不要-1.
+ 两种实现
```C++
//自己的方法
    int mySqrt(int x) {
        if(x==0) return 0;
        if(x==1||x==2||x==3) return 1;
        int left = 1, right = x/2;
        int res = BinarySearch(x,left,right);
        return res;
    }

    int BinarySearch(int x, int left, int right){
        while(left<right){
            long long mid = (left + right)/2;
            if((mid*mid) == x){
                return mid;
            } 
            if((mid*mid)<x){
               left = mid+1;
            }
            else{
                right = mid-1;
            }  
        }
        if(((long long)left*left<=x)){
            return left;
        }
        else{
            return left-1;
        }   
    }
//答案的方法
int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            }
            else {
                r = mid - 1;
            }
        }
        return ans;
    }
```
## 字符串压缩

1.题目
```
字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。
输入："aabcccccaaa"
 输出："a2b1c5a3"
输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```
2.**整数转字符串的方法！**

+ 一般来说itoa()函数是一个非标准的C / C++语言功能,因此不能好好的被所有编译器使用。在大多数Windows下的编译器通常在<cstdlib>头文件包含非标准函数。itoa()函数把整数转换成字符串，并返回指向转换后的字符串的指针。
	
+ **一种不使用库函数的模板**

```C++
string temp;
string res;
int count = 12;//任意整数
while(count){
     temp.push_back(count%10+'0');
     count /= 10;
 }
reverse(temp.begin(),temp.end());
for(auto ch : temp){
    res.push_back(ch);
 }
```

+ **使用to_string()函数**注意使用了字符串可以相加的性质
```C++
ans += ch + to_string(cnt); // 注意 cnt 要转为字符串
```
3. 实现
```C++
string compressString(string S) {
        string res;
        int len = S.size();
        if(len == 0||len == 1) return S;
        res.push_back(S[0]);
        int count = 1;
        string temp;
        for(int i=1;i<len;i++){
            if(S[i] == S[i-1]){
                count++;
            }
            else{
                // temp.clear();
                // while(count){
                //     temp.push_back(count%10+'0');
                //     count /= 10;
                // }
                // reverse(temp.begin(),temp.end());
                // for(auto ch : temp){
                //     res.push_back(ch);
                // }
                res += to_string(count);
                res.push_back(S[i]);
                count = 1;
            }
        }
        // temp.clear();
        // while(count){
        //     temp.push_back(count%10+'0');
        //      count /= 10;
        // }
        // reverse(temp.begin(),temp.end());
        // for(auto ch : temp){
        //      res.push_back(ch);
        // }
        res += to_string(count);
        if(res.size()>=len){
            return S;
        }
        else{
            return res;
        }
    }
```
	
## 二叉树的最近公共祖先

1.题目
```
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```
2.方法一
+ [此方法的详细解答](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)
+ 最近公共祖先的补充定义： 设节点root 为节点 p,q 的某公共祖先，若其左子节点root.left 和右子节点 root.right 都不是p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。根据以上定义，若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：
  - p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
  - p=root ，且 q 在 root 的左或右子树中；
  - q=root ，且 p 在 root 的左或右子树中；
+ 考虑通过递归对二叉树进行**后序遍历**，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。
+ 终止条件：
  - 当越过叶节点，则直接返回 null ；
  - 当 root 等于 p,q ，则直接返回 root ；
+ 递推工作：
  - 开启递归左子节点，返回值记为 left ；
  - 开启递归右子节点，返回值记为 right ；
+ 返回值： 根据 left 和 right ，可展开为四种情况；
  - 当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；
  - 当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
  - 当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：
    - p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
    - p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
  - 当 leftleft 不为空 ， rightright 为空 ：与情况 3. 同理；
+ 实现
```C++
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL||root->val == p->val||root->val == q->val) return root;//立即返回或终止的条件
        TreeNode* left = lowestCommonAncestor(root->left,p,q);//递归左子树
        TreeNode* right = lowestCommonAncestor(root->right,p,q);//递归右子树
        if(left == NULL&&right == NULL) return NULL;//返回情况1
        if(left == NULL) return right;//返回情况3
        if(right == NULL) return left;//返回情况4
        return root;//返回情况2
    }
```
3.方法二

+ 思路
  - 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。
+ 算法
  - 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。
  - 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。
  - 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。
+ 实现
```C++
unordered_map<int, TreeNode*> fa;
    unordered_map<int, bool> vis;
    void dfs(TreeNode* root){//算是后序遍历，并记录父节点吧
        if (root->left != nullptr) {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if (root->right != nullptr) {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        fa[root->val] = nullptr;
        dfs(root);
        while (p != nullptr) {//从p开始往上找父节点（父节点、父节点的父节点....）
            vis[p->val] = true;
            p = fa[p->val];
        }
        while (q != nullptr) {//把q找的父节点与p的作对比，一直对比，直到找到公共祖先
            if (vis[q->val]) return q;
            q = fa[q->val];
        }
        return nullptr;
    }
```
4.方法三（非常朴素且容易想到，就是有些用例会超时）

+ **就是遍历每个结点然后判断以该结点为根结点的遍历序列是否包含p，q**
+ 实现
```Java
class Solution {
    TreeNode res = new TreeNode(0);
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
     isParent(root, p, q);
     return res;  
    }

    public void isParent(TreeNode root, TreeNode p, TreeNode q){ //判断以当前根结点遍历的序列是否包含p，q，包含的话将全局变量res赋值为当前根结点
        Set<Integer> set = new HashSet<Integer>();
        preorderTraverse(root, set);
        if(set.contains(p.val) && set.contains(q.val))
            res = root;
        if(root.left != null)
            isParent(root.left, p, q);
        if(root.right != null)
            isParent(root.right, p, q);
    }

    public void preorderTraverse(TreeNode root, Set<Integer> set){ //先序遍历，建立遍历结点的hashSet；
        if(root != null){
            if(root.left != null)
                preorderTraverse(root.left, set);
            set.add(root.val);
            if(root.right != null)
                preorderTraverse(root.right, set);
        }
    }
```



## No.208也是字典树！！
**总结各种动态规划、BFS、DFS、滑窗算法的模板！！！！**

## 一个BFS的小小模板(借鉴了No.994)
```
while queue 非空:
	node = queue.pop()
    for node 的所有相邻结点 m:
        if m 未访问过:
            queue.push(m)
```

