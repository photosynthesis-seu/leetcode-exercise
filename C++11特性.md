# 目录
## 智能指针
- [智能指针背景介绍](#智能指针背景介绍)
- [shared_ptr](#shared_ptr)
- [unique_ptr](#unique_ptr)
- [weak_ptr](#weak_ptr)
- [智能指针的实现复杂版](#智能指针的实现复杂版)
- [智能指针的一些问题](#智能指针的一些问题)

## 多线程
- [多线程基础知识](#多线程基础知识)
- [多线程的生产者和消费者模式](#多线程的生产者和消费者模式)
- [创建多线程的实例](#创建多线程的实例)
- [两个线程轮流打印A和B](#两个线程轮流打印A和B)
- [多线程实现矩阵计算](#多线程实现矩阵计算)
- [线程池](#线程池)
- [读者写者问题](#读者写者问题)

## STL标准模板库
- [定义和六大部件](#定义和六大部件)
- [vector的简单实现](#vector的简单实现)
- [string的简单实现](#string的简单实现)
- [红黑树](#红黑树)
- [二叉查找树的实现](#二叉查找树的实现)

## 设计模式
- [单例模式](#单例模式)

## 智能指针背景介绍
+ C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。
+ 使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。
+ 从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。
+ 智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。
+ 智能指针还有一个作用是把值语义转换成引用语义

## shared_ptr
+ 多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。
+ 使用流程：
  - 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的。shared_ptr<int> p3(new int(1));的写法是正确的。
  - 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。
  - get函数获取原始指针。
  - 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。
  - 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。
+ 成员函数：
	
```
use_count() 返回引用计数的个数

unique() 返回是否是独占所有权( use_count 为 1)

swap() 交换两个 shared_ptr 对象(即交换所拥有的对象)

reset() 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少	
```
	
+ 简单的实现：
	
```C++
//shared计数放在这个结构体里面，实际上结构体里还应该有另一个weak计数。下文介绍weak_ptr时会解释。
struct SharedPtrControlBlock{
　　int shared_count;
};
//大概长这个样子（化简版）
template<class T>
class shared_ptr{
　　T* ptr;
　　SharedPtrControlBlock* count;
};

void runGame(){
　　std::shared_ptr<Monster> monster1(new Monster());//计数加到1

　　do{std::shared_ptr<Monster> monster2 = monster1;//计数加到2
　　}while(0);　　　　　　　　　　
　　//该栈退出后，计数减为1，monster1指向的堆对象仍存在

　　std::shared_ptr<Monster> monster3 = monster1;//计数加到2
}
//该栈退出后，shared_ptr都释放了，计数减为0，它们指向的堆对象也能跟着释放.
```
## unique_ptr
+ unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。
+ unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。
+ unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义（move）转移所有权。
+ 简单实现：
	
```C++
void runGame(){
　　std::unique_ptr<Monster> monster1(new Monster()); //monster1 指向 一个怪物
　　std::unique_ptr<Monster> monster2 = monster1; //Error!编译期出错，不允许复制指针指向同一个资源。
　　std::unique_ptr<Monster> monster3 = std::move(monster1); //转移所有权给monster3.
　　monster1->doSomething(); //Oops!monster1指向nullptr，运行期崩溃
}
```
## weak_ptr
+ weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator* 和 -> ,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。
+ weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。
+ 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
+ weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。
+ 成员函数：
```
expired() 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.

lock() 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.

use_count() 返回与 shared_ptr 共享的对象的引用计数.

reset() 将 weak_ptr 置空.
```
+ 简单实现：
```c++
计数区域(SharedPtrControlBlock)结构体引进新的int变量weak_count，来作为弱引用计数。
每个weak_ptr都占指针的两倍空间，一个装着原始指针，一个装着计数区域的指针（和shared_ptr一样的成员）。
weak_ptr可以由一个shared_ptr或者另一个weak_ptr构造。
weak_ptr的构造和析构不会引起shared_count的增加或减少，只会引起weak_count的增加或减少。

被管理资源的释放只取决于shared计数，当shared计数为0，才会释放被管理资源，
也就是说weak_ptr不控制资源的生命周期。

但是计数区域的释放却取决于shared计数和weak计数，当两者均为0时，才会释放计数区域。

//shared引用计数和weak引用计数
//之前的计数区域实际最终应该长这个样子
struct SharedPtrControlBlock{
　　int shared_count;
　　int weak_count;
};
//大概长这个样子（化简版）
template<class T>
class weak_ptr{
　　T* ptr;
　　SharedPtrControlBlock* count;
};

//weak_ptr没有重载 * 和 -> ，所以并不能直接使用资源。但可以使用lock()获得一个可用的shared_ptr对象，
//如果对象已经死了，lock()会失败，返回一个空的shared_ptr。
void runGame(){
　　std::shared_ptr<Monster> monster1(new Monster());
　　std::weak_ptr<Monster> r_monster1 = monster1;
　　r_monster1->doSomething();//Error! 编译器出错！weak_ptr没有重载* 和 -> ，无法直接当指针用
　　std::shared_ptr<Monster> s_monster1 = r_monster1.lock();//OK!可以通过weak_ptr的lock方法获得shared_ptr。
}
```
## 智能指针的实现复杂版

原始的简单实现
```C++
#include <iostream>
using namespace std;

template <typename T>
class SmartPointer {
public:

    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){
        if(p){
            *_reference_count = 1;
        }
        else{
            *_reference_count = 0;
        }

    }

    SmartPointer(const SmartPointer& src) {
        if(this!=&src) {
            _ptr = src._ptr;
            _reference_count = src._reference_count;
            (*_reference_count)++;
        }
    }

    SmartPointer& operator=(const SmartPointer& src) {
        if(_ptr==src._ptr) {
            return *this;
        }
        releaseCount();
        _ptr = src._ptr;
        _reference_count = src._reference_count;
        (*_reference_count)++;
        return *this;
    }


    T& operator*() {
        if(_ptr) {
            return *_ptr;
        }
        //throw exception
    }

    T* operator->() {
        if(ptr) {
            return _ptr;
        }
        //throw exception
    }

    ~SmartPointer() {
        if (--(*_reference_count) == 0) {
            delete _ptr;
            delete _reference_count;
        }
    }
private:
    T *_ptr;
    size_t *_reference_count;
    void releaseCount() {
        if(_ptr) {
            (*_reference_count)--;
            if((*_reference_count)==0) {
                delete _ptr;
                delete _reference_count;
            }
        }
    }
};
int main()
{
    SmartPointer<char> cp1(new char('a'));
    SmartPointer<char> cp2(cp1);
    SmartPointer<char> cp3;
    cp3 = cp2;
    cp3 = cp1;
    cp3 = cp3;
    SmartPointer<char> cp4(new char('b'));
    cp3 = cp4;
    cout<<*cp1<<endl;
}
```

1.计数器类的实现
+ counter对象的目地就是用来申请一个块内存来存引用基数，s是share_ptr的引用计数，w是weak_ptr的引用计数，当w为0时，删除Counter对象。
```C++
class Counter
{
public:
    Counter() : s(0), w(0){};
    int s;	//share_ptr的引用计数
    int w;	//weak_ptr的引用计数
};
```
2.shared_ptr的实现
+ shared_ptr的给出的函数接口为：构造，拷贝构造，赋值，解引用，通过release来在引用计数为0的时候删除_ptr和cnt的内存。
```C++
template <class T>
class WeakPtr; //为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用

template <class T>
class SharedPtr
{
public:
    SharedPtr(T *p = 0) : _ptr(p)
    {
        cnt = new Counter();
        if (p)
            cnt->s = 1;
        cout << "in construct " << cnt->s << endl;
    }
    ~SharedPtr()
    {
        release();
    }

    SharedPtr(SharePtr<T> const &s)
    {
        cout << "in copy con" << endl;
        _ptr = s._ptr;
        (s.cnt)->s++;
        cout << "copy construct" << (s.cnt)->s << endl;
        cnt = s.cnt;
    }
    SharedPtr(WeakPtr<T> const &w) //为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用
    {
        cout << "in w copy con " << endl;
        _ptr = w._ptr;
        (w.cnt)->s++;
        cout << "copy w  construct" << (w.cnt)->s << endl;
        cnt = w.cnt;
    }
    SharedPtr<T> &operator=(SharePtr<T> &s)
    {
        if (this != &s)
        {
            release();
            (s.cnt)->s++;
            cout << "assign construct " << (s.cnt)->s << endl;
            cnt = s.cnt;
            _ptr = s._ptr;
        }
        return *this;
    }
    T &operator*()
    {
        return *_ptr;
    }
    T *operator->()
    {
        return _ptr;
    }
    friend class WeakPtr<T>; //方便weak_ptr与share_ptr设置引用计数和赋值

protected:
    void release()
    {
        cnt->s--;
        cout << "release " << cnt->s << endl;
        if (cnt->s < 1)
        {
            delete _ptr;
            if (cnt->w < 1)
            {
                delete cnt;
                cnt = NULL;
            }
        }
    }

private:
    T *_ptr;
    Counter *cnt;
};
```
3.weak_ptr的实现
+ weak_ptr一般通过share_ptr来构造，通过expired函数检查原始指针是否为空，lock来转化为share_ptr。
```C++
template <class T>
class WeakPtr
{
public: //给出默认构造和拷贝构造，其中拷贝构造不能有从原始指针进行构造
    WeakPtr()
    {
        _ptr = 0;
        cnt = 0;
    }
    WeakPtr(SharePtr<T> &s) : _ptr(s._ptr), cnt(s.cnt)
    {
        cout << "w con s" << endl;
        cnt->w++;
    }
    WeakPtr(WeakPtr<T> &w) : _ptr(w._ptr), cnt(w.cnt)
    {
        cnt->w++;
    }
    ~WeakPtr()
    {
        release();
    }
    WeakPtr<T> &operator=(WeakPtr<T> &w)
    {
        if (this != &w)
        {
            release();
            cnt = w.cnt;
            cnt->w++;
            _ptr = w._ptr;
        }
        return *this;
    }
    WeakPtr<T> &operator=(SharePtr<T> &s)
    {
        cout << "w = s" << endl;
        release();
        cnt = s.cnt;
        cnt->w++;
        _ptr = s._ptr;
        return *this;
    }
    SharePtr<T> lock()
    {
        return SharePtr<T>(*this);
    }
    bool expired()
    {
        if (cnt)
        {
            if (cnt->s > 0)
            {
                cout << "empty" << cnt->s << endl;
                return false;
            }
        }
        return true;
    }
    friend class SharePtr<T>; //方便weak_ptr与share_ptr设置引用计数和赋值
protected:
    void release()
    {
        if (cnt)
        {
            cnt->w--;
            cout << "weakptr release" << cnt->w << endl;
            if (cnt->w < 1 && cnt->s < 1)
            {
                //delete cnt;
                cnt = NULL;
            }
        }
    }

private:
    T *_ptr;
    Counter *cnt;
};
```

## 智能指针的一些问题

1.空悬指针问题
+ 空悬指针问题是指：无法知道指针指向的堆内存是否已经释放。
+ 得益于引入的weak_count,weak_ptr指针可以使计数区域的生命周期受weak_ptr控制，从而能使weak_ptr获取 被管理资源的shared计数，从而判断被管理对象是否已被释放。（可以实时动态地知道指向的对象是否被释放,从而有效解决空悬指针问题）
+ 它的成员函数expired()就是判断指向的对象是否存活。

2.循环引用问题

+ weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

```C++
class B;	//声明
class A
{
public:
	shared_ptr<B> pb_;
	~A()
	{
		cout << "A delete\n";
	}
};
class B
{
public:
	shared_ptr<A> pa_;
	~B()
	{
		cout << "B delete\n";
	}
};
void fun()
{
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	cout << pb.use_count() << endl;	//1
	cout << pa.use_count() << endl;	//1
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout << pb.use_count() << endl;	//2
	cout << pa.use_count() << endl;	//2
}
int main()
{
	fun();
	return 0;
}
```
+ 可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减1，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A、B的析构函数没有被调用）运行结果没有输出析构函数的内容，造成内存泄露。如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_，改为weak_ptr pb_ ，运行结果如下：
```C++
1
1
1
2
B delete
A delete
```

## 多线程基础知识

[推荐教程地址](https://blog.csdn.net/caoshangpa/article/details/80374651)

1. 与C++11多线程相关的头文件
```
C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是<atomic> ,<thread>,<mutex>,<condition_variable>。

<atomic>：
该头文主要声明了两个类, std::atomic和std::atomic_flag，另外还声明了一套C风格的原子类型和与C兼容的原子操作的函数。

<thread>：
该头文件主要声明了 std::thread 类，另外 std::this_thread 命名空间也在该头文件中。

<mutex>：
该头文件主要声明了与互斥量(mutex)相关的类，包括std::mutex系列类， std::lock_guard，std::unique_lock，以及其他的类型和函数。                    

<condition_variable>：
该头文件主要声明了与条件变量相关的类，包括 std::condition_variable和std::condition_variable_any。
```
2.<mutex>头文件简介
	
```
Mutex又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <mutex> 头文件。

(1)Mutex系列类(四种)
std::mutex，最基本的 Mutex 类。
std::recursive_mutex，递归 Mutex 类。
std::time_mutex，定时 Mutex 类。
std::recursive_timed_mutex，定时递归 Mutex 类。

(2)Lock系列类（两种）
std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。
std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。

(3)其他类型（结构体）
std::adopt_lock_t——它的常量对象定义为constexpr adopt_lock_t adopt_lock {};//constexpr 是C++11 中的新关键字）
std::defer_lock_t——它的常量对象定义为constexpr defer_lock_t defer_lock {}; //constexpr 是C++11 中的新关键字）
std::try_to_lock_t——它的常量对象定义为constexpr try_to_lock_t try_to_lock {};//constexpr 是C++11 中的新关键字)

(4)函数
std::try_lock，尝试同时对多个互斥量上锁。
std::lock，可以同时对多个互斥量上锁。
std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。
```
3.mutex简单使用
- std::mutex类
  - 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。
  - lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：①如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。②如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。③如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。
  - unlock()， 解锁，释放对互斥量的所有权。
  - try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况：① 如果该互斥量当前没有被锁住，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。②如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。③如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。不论是lock()还是try_lock()都需要和unlock()配套使用.
  - 示例
```C++
#include <thread>
#include <iostream>
#include <string>
#include <chrono>
#include <assert.h>
#include <mutex>
int counter=0;
std::mutex mtx;
// 由于lock()的阻塞特性，所以每个线程都统计了10000次，一共是10*10000=100000次。
void func()
{
    for (int i=0; i<10000; ++i)
    {
            mtx.lock();
            ++counter;
            mtx.unlock();
    }
}
int main()
{
    std::thread workerThreads[10];
    for (int i=0; i<10; ++i)
    {
        workerThreads[i] = std::thread(func);
    }
    for (auto& workerThread : workerThreads)
    {
        workerThread.join();
    }
    std::cout << counter << " successful increases of the counter"<<std::endl;
 
    return 0;
}
//由于try_lock()的非阻塞特性，如果当前互斥量被其他线程锁住，则当前try_lock()返回 false，此时counter并不会增加1。
//所以这十个线程的统计结果具有随机性，下次运行程序时，统计值不一定是16191。
void func()
{
    for (int i=0; i<10000; ++i)
    {
        if (mtx.try_lock())
        {
            ++counter;
            mtx.unlock();
        }
    }
}
int main()
{
    std::thread workerThreads[10];
    for (int i=0; i<10; ++i)
    {
        workerThreads[i] = std::thread(func);
    }
    for (auto& workerThread : workerThreads)
    {
        workerThread.join();
    }
    std::cout << counter << " successful increases of the counter"<<std::endl;
 
    return 0;
}
```
- std::lock_guard和std::unique_lock类
  - std::lock_guard使用起来比较简单，除了构造函数外没有其他成员函数。
  - std::unique_lock除了lock_guard的功能外，提供了更多的成员函数，相对来说更灵活一些。这些成员函数包括lock，try_lock，try_lock_for，try_lock_until、unlock等。
    - std::unique_lock::lock——用它所管理的Mutex对象的 lock 函数。
    - std::unique_lock::try_lock——用它所管理的Mutex对象的 try_lock函数。
    - std::unique_lock::unlock——用它所管理的Mutex对象的 unlock函数。
  - **这两个类相比使用std::mutex的优势在于不用配对使用，无需担心忘记调用unlock而导致的程序死锁**。
  - 示例
```C++
#include <thread>
#include <iostream>
#include <string>
#include <chrono>
#include <assert.h>
#include <mutex>
int counter=0;
std::mutex mtx;
void func()
{
    //方法1
    for (int i=0; i<10000; ++i)
    {
        //将std::lock_guard替换成std::unique_lock，效果是一样的
        std::lock_guard<std::mutex> lck (mtx);
        ++counter;
    }
    //方法2
    for (int i=0; i<10000; ++i)
    {
        mtx.lock();
        //注意此时Tag参数为std::adopt_lock表明当前线程已经获得了锁，
        //此后mtx对象的解锁操作交由unique_lock对象lck来管理，在lck的生命周期结束之后，
        //mtx对象会自动解锁。
        std::unique_lock<std::mutex> lck(mtx,std::adopt_lock);
        ++counter;
    }
    //方法3
    for (int i=0; i<10000; ++i)
    {
        //注意此时Tag参数为std::defer_lock表明当前线程没有获得了锁，
        //需要通过lck的lock和unlock来加锁和解锁，
        std::unique_lock<std::mutex> lck(mtx,std::defer_lock);
        lck.lock();
        ++counter;
        lck.unlock();
    }      
}
 
int main()
{
    std::thread workerThreads[10];
    for (int i=0; i<10; ++i)
    {
        workerThreads[i] = std::thread(func);
    }
    for (auto& workerThread : workerThreads)
    {
        workerThread.join();
    }
    std::cout << counter << " successful increases of the counter"<<std::endl;
 
    return 0;
}
```
4.线程同步-条件变量
- C++标准库对条件变量有两套实现：std::condition_variable和std::condition_variable_any。
- 这两个实现都包含在<condition_variable> 头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与std::mutex一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了_any的后缀。
- 因为std::condition_variable_any更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以std::condition_variable一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考std::condition_variable_any。
- 下例使用std::condition_variable去处理之前提到的情况——当有数据需要处理时，如何唤醒休眠中的线程对其进行处理。
```C++

#include <thread>
#include <iostream>
#include <string>
#include <chrono>
#include <assert.h>
#include <mutex>
#include <condition_variable>
#include <queue>
int counter=0;
std::mutex mtx;
std::queue<int> dataQuene;
std::condition_variable dataCondition;
void func_preparation()
{
    for (int i=0; i<10; ++i)
    {
        std::unique_lock<std::mutex> lck(mtx);
        ++counter;
        dataQuene.push(counter);
        dataCondition.notify_one();
    }
}
void func_processing()
{
    while (true)
    {
        std::unique_lock<std::mutex> lck(mtx);
        dataCondition.wait(lck,[]{return !dataQuene.empty();});
        int num=dataQuene.front();
        std::cout<<num<<std::endl;
        dataQuene.pop();
        lck.unlock();
    }
}
int main()
{  
    std::thread workerThreadPreparation(func_preparation);
    workerThreadPreparation.detach();
    std::thread workerThreadProcessing(func_processing);
    workerThreadProcessing.detach();
    
    system("pause");
    return 0;
}
```
## 多线程的生产者和消费者模式
1.实现
```C++
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
 
int counter=0;
int maxSize = 30;
std::mutex mtx;
std::queue<int> dataQuene; // 被生产者和消费者共享
 
std::condition_variable producer, consumer;  // 条件变量是一种同步机制，要和mutex以及lock一起使用
void func_consumer()
{
    while (true)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));// 消费者比生产者慢
 
        std::unique_lock<std::mutex> lck(mtx);
        consumer.wait(lck, [] {return dataQuene.size() != 0; });     // 消费者阻塞等待， 直到队列中元素个数大于0
        int num=dataQuene.front();
        dataQuene.pop();
        std::cout << "consumer " << std::this_thread::get_id() << ": "<< num <<std::endl;
 
        producer.notify_all();                                       // 通知生产者当队列中元素个数小于maxSize
    }
}
void func_producer()
{
    while (true)
    {
        std::this_thread::sleep_for(std::chrono::milliseconds(900));  // 生产者稍微比消费者快
        std::unique_lock<std::mutex> lck(mtx);
        producer.wait(lck, [] {return dataQuene.size() != maxSize; });// 生产者阻塞等待， 直到队列中元素个数小于maxSize
 
        ++counter;
        dataQuene.push(counter);
        std::cout << "producer " << std::this_thread::get_id() << ": "<< counter <<std::endl;
 
        consumer.notify_all();                                        //通知消费者当队列中的元素个数大于0
    }
}
int main()
{
    std::thread consumers[2], producers[2];
 
    // 两个生产者和消费者
    for (int i = 0; i < 2; ++i)
    {
        consumers[i] = std::thread(func_consumer);
        producers[i] = std::thread(func_producer);
    }
 
    for (int i = 0; i < 2; ++i)
    {
        producers[i].join();
        consumers[i].join();
    }
 
    system("pause");
    return 0;
}
```


## 创建多线程的实例

1.hello world
```C++
#include <thread>
#include <iostream>
using namespace  std;
void func()
{
    cout<<"worker thread ID:"<<this_thread::get_id()<<endl;
    cout<<"Hello Word"<<endl;

}
//通过thread类直接申明一个线程workerThread，参数是这个线程执行的回调函数的地址，
//通过jion()方法阻塞主线程，直到workerThread线程执行结束为止。
int main()
{
    cout<<"main thread ID:"<<this_thread::get_id()<<endl;
    thread workerThread(func);
    workerThread.join();
    return 0;
}
```
2.使用参数启动线程
```C++
#include <thread>
#include <iostream>
#include <string>

void func(int i,std::string const &s)
{
    std::cout<<"worker thread ID:"<<std::this_thread::get_id()<<std::endl;
    std::cout<<"Hello Word"<<" "<<s<<" "<<i<<std::endl;
}
 
int main()
{
    std::cout<<"main thread ID:"<<std::this_thread::get_id()<<std::endl;
    std::string str="at";
    //注意这里第二个参数的写法
    //为何不直接传str:虽然函数func的第二个参数期待传入一个引用，但是std::thread得构造函数
    //并不知晓；构造函数无视函数期待的数据类型，并盲目的拷贝已提供的变量。当线程调用func函数
    //时，传递给函数的参数是str变量内部拷贝的引用，而非数据本身的引用。使用std::ref可以解决
    //这个问题，将参数转换成引用的形式。
    std::thread workerThread(func,20161016,std::ref(str));
    workerThread.join();
 
    return 0;
}

```
3.在后台运行线程
```C++
#include <thread>
#include <iostream>
#include <string>
#include <chrono>
#include <assert.h>
 
void func(int i,std::string const &s)
{
    std::cout<<"worker thread ID:"<<std::this_thread::get_id()<<std::endl;
    std::cout<<"Hello Word"<<" "<<s<<" "<<i<<std::endl;
}
 
int main()
{
    std::cout<<"main thread ID:"<<std::this_thread::get_id()<<std::endl;
    std::string str="at";
    std::thread workerThread(func,20161016,std::ref(str));
    //使用detach()会让线程在后台运行，也就是说主线程不会等待workerThread结束。如果线程detach(),
    //不可能有std::thread对象能引用它，而且不能再调用该线程的join()方法。
    workerThread.detach();
    //workerThread.joinable()为false
    assert(!workerThread.joinable());
    //延时10秒，否则然函数func函数还未执行，man函数就退出了
    std::this_thread::sleep_for(std::chrono::seconds(10));
 
    return 0;
}
```
## 两个线程轮流打印A和B

1.轮流打印A、B、C的实现
```C++
#include <thread>
#include <vector>
#include <mutex>
#include <iostream>

using namespace std;

mutex mtx;
condition_variable cv;//信号量

char arr[] = { 'a','b','c' };
char message = 'a';

void test(int i) {
    for(int j = 0 ;j < 10;++j){
        unique_lock<mutex> lk(mtx);
        cv.wait(lk, [=] {return message == arr[i];});
        cout << arr[i];
        message = arr[(i + 1) % 3];
        lk.unlock();
        cv.notify_all();
    }
}

int main()
{
    thread t[3];
    for (int i = 0; i < 3; ++i) {
        t[i] = thread(test,i);
    }

    for (int i = 0; i < 3; ++i) {
        t[i].join();
    }
    return 0;
}
```


2.轮流打印A、B的实现
```C++
#include <thread>
#include <iostream>
#include <mutex>
#include <condition_variable>

std::mutex data_mutex;
std::condition_variable data_var;
bool flag = true;

void printA()
{
    while(1)
    {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::unique_lock<std::mutex> lck(data_mutex) ;
        data_var.wait(lck,[]{return flag;});
        std::cout<<"thread: "<< std::this_thread::get_id() << "   printf: " << "A" <<std::endl;
        flag = false;
        data_var.notify_one();
    }
}

void printB()
{
    while(1)
    {
        std::unique_lock<std::mutex> lck(data_mutex) ;
        data_var.wait(lck,[]{return !flag;});
        std::cout<<"thread: "<< std::this_thread::get_id() << "   printf: " << "B" <<std::endl;
        flag = true;
        data_var.notify_one();
    }
}

int main()
{
    std::thread tA(printA);
    std::thread tB(printB);
    tA.join();
    tB.join();
    return 0;
}
```

## 线程池

1.背景和定义
  - 目前的大多数网络服务器，包括Web服务器、Email服务器以及数据库服务器等都具有一个共同点，就是单位时间内必须处理数目巨大的连接请求，但处理时间却相对较短。
  - 传统多线程方案中我们采用的服务器模型则是一旦接受到请求之后，即创建一个新的线程，由该线程执行任务。任务执行完毕后，线程退出，这就是是“即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数极其频繁，那么服务器将处于不停的创建线程，销毁线程的状态。
  - 我们将传统方案中的线程执行过程分为三个过程：T1、T2、T3。T1：线程创建时间T2：线程执行时间，包括线程的同步等时间T3：线程销毁时间
  - 那么我们可以看出，线程本身的开销所占的比例为(T1+T3) / (T1+T2+T3)。如果线程执行的时间很短的话，这比开销可能占到20%-50%左右。如果任务执行时间很长的话，这笔开销将是不可忽略的。
  - 除此之外，线程池能够减少创建的线程个数。通常线程池所允许的并发线程是有上界的，如果同时需要并发的线程数超过上界，那么一部分线程将会等待。而传统方案中，如果同时请求数目为2000，那么最坏情况下，系统可能需要产生2000个线程。尽管这不是一个很大的数目，但是也有部分机器可能达不到这种要求。
  - 因此线程池的出现正是着眼于减少线程本身带来的开销。线程池采用预创建的技术，在应用程序启动之后，将立即创建一定数量的线程(N1)，放入空闲队列中。这些线程都是处于阻塞（Suspended）状态，不消耗CPU，但占用较小的内存空间。当任务到来后，缓冲池选择一个空闲线程，把任务传入此线程中运行。当N1个线程都在处理任务后，缓冲池自动创建一定数量的新线程，用于处理更多的任务。在任务执行完毕后线程也不退出，而是继续保持在池中等待下一次的任务。当系统比较空闲时，大部分线程都一直处于暂停状态，线程池自动销毁一部分线程，回收系统资源。
  - 基于这种预创建技术，线程池将线程创建和销毁本身所带来的开销分摊到了各个具体的任务上，执行次数越多，每个任务所分担到的线程本身开销则越小，不过我们另外可能需要考虑进去线程之间同步所带来的开销

2.使用场景
  - 事实上，线程池并不是万能的。它有其特定的使用场合。线程池致力于减少线程本身的开销对应用所产生的影响，这是有前提的，前提就是线程本身开销与线程执行任务相比不可忽略。如果线程本身的开销相对于线程任务执行开销而言是可以忽略不计的，那么此时线程池所带来的好处是不明显的，比如对于FTP服务器以及Telnet服务器，通常传送文件的时间较长，开销较大，那么此时，我们采用线程池未必是理想的方法，我们可以选择“即时创建，即时销毁”的策略。
总之线程池通常适合下面的几个场合：
  - (1)单位时间内处理任务频繁而且任务处理时间短
  - (2)对实时性要求较高。如果接受到任务后在创建线程，可能满足不了实时要求，因此必须采用线程池进行预创建。

## 单例模式

1.定义：单例模式（Singleton Pattern）是设计模式中最简单的形式之一，其目的是使得类的一个对象成为系统中的唯一实例。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。

2.要点：
- 单例类有且仅有一个实例
- 单例类必须自行创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

从具体实现角度来说，可分为以下三点：
- 提供一个 private 构造函数（防止外部调用而构造类的实例）
- 提供一个该类的 static private 对象
- 提供一个 static public 函数，用于创建或获取其本身的静态私有对象（例如：GetInstance()）

除此之外，还有一些关键点（需要多加注意，很容易忽视）：
- 线程安全（双检锁 - DCL，即：double-checked locking）
- 资源释放

3.**局部静态变量**
+ 一种简单示例
```C++
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H
// 非真正意义上的单例
class Singleton
{
//错误的方法
public:
    static Singleton& GetInstance()
    {
        static Singleton instance;
        return instance;
    }
//一种简单改进的方法
public:
    // 修改返回类型为指针类型
    static Singleton* GetInstance()
    {
        static Singleton instance;
        return &instance;
    }
private:
    Singleton() {}
};
#endif // SINGLETON_H
```
但是，这并非真正意义上的单例。当使用如下方式访问单例时：Singleton single = Singleton::GetInstance();这会出现了一个类拷贝问题，从而违背了单例的特性。产生这个问题原因在于：编译器会生成一个默认的拷贝构造函数，来支持类的拷贝。为了避免这个问题，有两种解决方式：（1）将 GetInstance() 函数的返回类型修改为指针，而非引用。（2）显式地声明类的拷贝构造函数，并重载赋值运算符。
+ **改进**
修改默认拷贝构造函数，这样以来，既可以保证只存在一个实例，又不用考虑内存回收的问题。
```C++
// singleton.h
#ifndef SINGLETON_H
#define SINGLETON_H
#include <iostream>
using namespace std;
// 单例
class Singleton
{
public:
    static Singleton& GetInstance()
    {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        cout << "Do something" << endl;
    }
private:
    Singleton() {}  // 构造函数（被保护）
    Singleton(Singleton const &);  // 无需实现
    Singleton& operator = (const Singleton &);  // 无需实现
};
#endif // SINGLETON_H

//运行例子
Singleton::GetInstance().doSomething();  // OK
Singleton single = Singleton::GetInstance();  // Error 不能编译通过
```
这样以来，既可以保证只存在一个实例，又不用考虑内存回收的问题。

4.**懒汉/饿汉模式**
+ 懒汉式的特点：
  - Lazy 初始化
  - 非多线程安全
  - 优点：第一次调用才初始化，避免内存浪费。
  - 缺点：必须加锁（在“线程安全”部分分享如何加锁）才能保证单例，但加锁会影响效率。
```C++
// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）
    Singleton(Singleton const &);  // 无需实现
    
private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
};
// 单例 - 懒汉式
Singleton *Singleton::m_pSingleton = NULL;
Singleton *Singleton::GetInstance()
{
    if (m_pSingleton == NULL)
        m_pSingleton = new Singleton();
    return m_pSingleton;
}
```
+ 饿汉式的特点：
  - 非 Lazy 初始化
  - 多线程安全
  - 优点：没有加锁，执行效率会提高。
  - 缺点：类加载时就初始化，浪费内存。
```C++
// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）
    Singleton(Singleton const &);  // 无需实现
    
private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
};
// 单例 - 饿汉式
Singleton *Singleton::m_pSingleton = new Singleton();
Singleton *Singleton::GetInstance()
{
    return m_pSingleton;
}
```
5.**线程安全的单例模式（双检锁）**
```C++
#include <iostream>
#include <mutex>
using namespace std;

// 单例 - 懒汉式/饿汉式公用
class Singleton
{
public:
    static Singleton* GetInstance();

private:
    Singleton() {}  // 构造函数（被保护）
    Singleton(Singleton const &);  // 无需实现

private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
    static mutex m_mutex;  // 锁
};

// 单例 - 懒汉式（双检锁 DCL 机制）
Singleton *Singleton::m_pSingleton = NULL;
mutex Singleton::m_mutex;

Singleton *Singleton::GetInstance()
{
    if (m_pSingleton == NULL) {
        std::lock_guard<std::mutex> lock(m_mutex);  // 自解锁
        if (m_pSingleton == NULL) {
            m_pSingleton = new Singleton();
        }
    }
    return m_pSingleton;
}
```
6.**资源释放**
```C++
#include <iostream>
using namespace std;
// 单例 - 自动释放
class Singleton
{
public:
    static Singleton* GetInstance();
private:
    Singleton() {}  // 构造函数（被保护）
private:
    static Singleton *m_pSingleton;  // 指向单例对象的指针
    // GC 机制
    class GC
    {
    public:
        ~GC()
        {
            // 可以在这里销毁所有的资源，例如：db 连接、文件句柄等
            if (m_pSingleton != NULL) {
                cout << "Here destroy the m_pSingleton..." << endl;
                delete m_pSingleton;
                m_pSingleton = NULL;
            }
        }
        static GC gc;  // 用于释放单例
    };
};
Singleton::GC Singleton::GC::gc; // 重要
int main()
{
    Singleton *pSingleton1 = Singleton::GetInstance();
    Singleton *pSingleton2 = Singleton::GetInstance();
    cout << (pSingleton1 == pSingleton2) << endl;
    return 0;
}
```


## 定义和六大部件
1. 六大部件：容器、分配器、算法、迭代器、适配器、仿函数(Components：Containers, Allocators, Algorithms, Iterators, Adapters, Functors)
2. 六大部件之间的关系：Container通过Allocator取得数据存储空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同的策略变化，Adapter可以修饰或套接Functor
3. 容器分类：Sequence、Associative、Unordered
4. 空间配置器(分配器-Allocators)
+ C++中new和delete其实都包含两步操作，new包含了申请内存、调用构造函数，delete包含了调用析构函数、释放内存。而 allocator为了更加精密分工，区分开了两个步骤：allocate和deallocate负责内存申请和释放，construct和destory负责构造和析构。
+ 为了解决内存碎片的问题，SGI STL设计了**双层配置器**，第一级直接使用malloc和free，第二级按照不同情况采用不同策略：当配置区块超过128bytes时，视之为“足够大”，便调用第一级配置器。当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用复杂的memory pool整理方式，而不再求助于第一级配置器。
+ 内存池:每次配置一大块内存，以内存链表的方式进行管理。为了方便管理，所有区块的内存都会被调整至8的倍数，并维护16个free-lists，分别为8bytes~128bytes，每个free-lists中都存在相同大小的一些区块。内存池的处理主要有一下一些情况：
  - 内存池空间足够，直接分配空间
  - 内存池空间不满足所有需求，但是能够分配一个区块以上的大小，分配能分配的最大空间。 
  - 内存池空间连一个区块都无法满足，尝试使用malloc进行申请，扩展内存池大小然后分配。
  - malloc申请失败，则尝试用第一级配置器，因为其中有针对申请空间失败的处理(new-handler机制)，可能能够释放其他的内存来使用，如果失败会抛出异常。
5. 迭代器(Iterators)
+ 迭代器简单来说就是提供一种方法，在不需要暴露容器的内部表现形式情况下，使之能依次访问容器中的各个元素。另外，通过迭代器容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。
+ **迭代器设计思维**：STL中迭代器的中心思想是将容器和算法分开，彼此独立设计，最后通过迭代器结合在一起。迭代器是一种行为类似指针的对象，最重要的就是对operator*和oprator->进行重载。还有++ +n -- -n > < >= <= ==
```C++
template<typename InputIterator, typename T>
InputIterator find(InputIterator first, InputIterator last, const T &value)
{
    while (first != last && *frist != value)
        ++first;
    return first;
}
```
## 红黑树
[详细解读的文章](https://www.jianshu.com/p/e136ec79235c)
1. 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：
  - 性质1：每个节点要么是黑色，要么是红色。
  - 性质2：根节点是黑色。
  - 性质3：每个叶子节点（NIL）是黑色。
  - 性质4：每个红色结点的两个子结点一定都是黑色。
  - 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点
  
2.红黑树并不是一个完美平衡二叉查找树,根结点的左子树可能比右子树高2，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为**黑色完美平衡**。

3.红黑树能自平衡，依赖三种操作：左旋、右旋和变色。
- 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
- 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
- 变色：结点的颜色由红变黑或由黑变红。

4.插入新结点时的操作：
+ **第一步: 将红黑树当作一颗二叉查找树，将节点插入。** 红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！
+ **第二步：将插入的节点着色为"红色"** 由于性质的约束：插入点不能为黑节点，应插入红节点。因为你插入黑节点将破坏性质5，所以每次插入的点都是红结点，但是若他的父节点也为红，那岂不是破坏了性质4？对啊，所以要做一些“旋转”和一些节点的变色。
+ **第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树** 那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。
+ (1)情况说明：被插入的节点是根节点。 处理方法：直接把此节点涂为黑色。(2)情况说明：被插入的节点的父节点是黑色。 处理方法：什么也不需要做。节点被插入后，仍然是红黑树。 (3)情况说明：被插入的节点的父节点是红色。 处理方法：那么，被插入节点一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。
![image](https://github.com/photosynthesis-seu/leetcode-exercise/blob/master/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/152510_i5PN_2243330.jpg)
+ 上面三种情况(Case)处理问题的核心思路都是：将红色的节点逐步移到根节点；然后，将根节点设为黑色。

5.删除结点时的操作：
+ 不需要调整的情况：
  - 被删除结点的是红色的；
  - 被删除结点只有一个孩子，用孩子的值替换被删除节点，删除孩子结点。
+ 需要调整的情况：（被删除节点为黑色）因为左右对称的缘故，在此只讨论父结点位于祖父节点的左支的情况：
  - 兄弟节点为红色：这时候需要互换父结点和兄弟节点的颜色，并进行左旋操作。
  - 兄弟节点为黑色，且其左右孩子也为黑色：将兄弟节点涂成红色，再将父结点当成新的被删除结点（只是当成，并不删除）进行一次调整。
  - 兄弟节点为黑色，且其左孩子为红色：先换色—左孩子涂成黑色，兄弟节点涂成红色；再以兄弟节点为支点右旋。变成情况4 
  - 兄弟节点为黑色，且其右孩子为红色：先换色—父结点的颜色赋给兄弟节点，父结点涂成黑色，兄弟节点的右孩子涂成黑色；再左旋。

## 多线程实现矩阵计算

1.基础知识
+ 要实现矩阵乘法 C = A * B 。为了讨论方便，先假设所有矩阵都是n阶方阵（后面实现的时候再改为一般形式）。假定矩阵是按行存储的。最普通的实现方式如下：
```C++
for(int i=0;i<n;++i)
    for(int j=0;j<n;++j)
        for(int k=0;k<n;++k)
            C[i][j]+=A[i][k]*B[k][j];
```
+ 加速计算的最简单的一个技巧：调换循环顺序。例如将原来的**ijk**顺序改成**ikj**顺序：
```C++
for(int i=0;i<n;++i)
    for(int k=0;k<n;++k)
        s=A[i][k];
        for(int j=0;j<n;++j)
            C[i][j]+=s*B[k][j];
```
  - 对于一千阶的矩阵，速度提升5倍左右。造成矩阵乘法慢的原因，除了算法上的 O(n^3) 以外，还有**内存访问不连续**。这会导致**cache命中率不高**。所以为了加速，就要尽可能使内存访问连续，即不要跳来跳去。我们定义一个概念：**跳跃数，来衡量访问的不连续程度**。
  - 对于最普通的实现方式（顺序： ijk ），它是依次计算 C 中的每个元素。当计算 C 中任一个元素时，需要将 A 对应的行与 B 对应的列依次相乘相加。**之前已假设过，矩阵是按行存储的**，所以在 A 相应行中不断向右移动时，内存访问是连续的。**但 B 相应列不断向下移动时，内存访问是不连续的**。计算完 C 的一个元素时， B 相应列中已经间断地访问了 n 次，而 A 只间断 1 次（这一次就是算完后跳转回本行的开头），故总共是 n+1 次。这样计算完 C 中所有 n^2 个元素，跳转了 n^3+n^2 次。但刚才没有计数 C 的跳转次数，加上以后是 n^3+n^2+n 。
  - 而如果以顺序 ikj 实现，它将 C 中元素一行一行计算。当计算 C 中任一行的第一个元素时，先访问 A 中相应行的第一列元素，和 B 中第一列的第一行元素，然后 B 不断往右挪（不间断），算完后跳转到下一行（如果二维数组则间断一次，一维数组不间断），此时 A 往右挪一个元素（不间断）。依次这样挪动，**这样算完 C 的这一行元素后，恰好按顺序将 B 遍历一遍**，间断了 n 次（一维数组是 1 次），且恰好从左往右遍历了 A 的相应行，间断了 1 次（一维数组没有间断），加起来是 n+1 次（一维数组是 1 次）。故算完 C 的所有 n 行后，跳转了 n^2+n 次（一维数组是 n 次）。刚才没有算 C 的跳转，算上后跳跃数是 2n^2+n 次（一维数组是 n 次）。
  - 由此可见：将原来的ijk顺序改成ikj顺序,跳跃数更少，少一个数量级，故速度更快！
+ 实现
```C++
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<thread>
#include<ctime>
 
using namespace std;
 
// f mn = d mt * e tn
vector<vector<int> > d;
vector<vector<int> > e;
vector<vector<int> > f;
 
//single thread单线程计算矩阵
void mulSingle()
{
	int m = d.size();
	int t = d[0].size();
	int n = e[0].size();
	// ikj is faster than ijk (memory access issues)
	for (int i = 0; i < m; ++i)
		for (int k = 0; k < t; ++k)
		{
			int s = d[i][k];
			for (int j = 0; j < n; ++j)
				f[i][j] += s * e[k][j];
		}
}
 
//multi thread多线程计算矩阵
void mulMulti(int rowStart, int rowEnd)
{
	int m = d.size();
	int t = d[0].size();
	int n = e[0].size();
	// ikj is faster than ijk (memory access issues)
	for (int i = rowStart; i < rowEnd; ++i)
		for (int k = 0; k < t; ++k)
		{
			int s = d[i][k];
			for (int j = 0; j < n; ++j)
				f[i][j] += s * e[k][j];
		}
}
// create a matrix自动的创建一个矩阵，简单是初始化里面的值
vector<vector<int> > createMat(int m, int n) {
	vector<vector<int> > ans(m, vector<int>(n, 0));
	for (int i = 0; i < m; i++)
		for (int j = 0; j < n; j++)
			ans[i][j] = i - j - 1;   // arbitrary value
	return ans;
}
int main()
{
	clock_t startTime, endTime;
 
	// initializing matrices
	d = createMat(80, 50);
	e = createMat(50, 22);
 
	// f (m*n) = d (m*t) * e (t*n)
	int m = d.size();
	int t = d[0].size();
	int n = e[0].size();
 
	f.resize(m);
	for (int i = 0; i < m; ++i)
		f[i].resize(n);
 
	//single thread
	startTime = clock();
	mulSingle();
	endTime = clock();
 
	//display
	for (auto cur : f)
	{
		for (auto i : cur)
			cout << i << " ";
		cout << endl;
	}	
	cout << "Single Thread Total Time : " << (double)(endTime - startTime)\
		/ CLOCKS_PER_SEC << " s" << endl;
 
	// initializing matrix
	f.clear();
	f.resize(m);
	for (int i = 0; i < m; ++i)
		f[i].resize(n);
	cout << endl;
 
	//multiple thread
	startTime = clock();
	int div = m / 4;
	thread t1(mulMulti, 0, div);
	thread t2(mulMulti, div, 2 * div);
	thread t3(mulMulti, 2 * div, 3 * div);
	thread t4(mulMulti, 3 * div, m);
	t1.join();
	t2.join();
	t3.join();
	t4.join();
	endTime = clock();
 
	//display
	for (auto cur : f)
	{
		for (auto i : cur)
			cout << i << " ";
		cout << endl;
	}	
	cout << "Multiple Thread Total Time : " << (double)(endTime - startTime)\
		/ CLOCKS_PER_SEC << " s" << endl;
 
	//this_thread::sleep_for(chrono::seconds(5));
	system("pause");
	return 0;
}
```
## vector的简单实现
1.参考
```C++
template<class T>
class Myvector{
public:
//构造函数，复制构造函数以及析构函数
    Myector(int size=0):theSize(size),theCapacity(0+SPACE_CAPACITY){
        objects=new T[theCapacity];
    }
    Myector(const Vector& rhs):objects(NULL){
        operator=(rhs);
    }
    ~Myvector(){
        if(objects != NULL){
            delete[] objects;
            objects = NULL;
        }
    }
//调整size
    void resize(int newSize){
        if(newSize>theCapacity)
            reserve(newSize*2+1);
        theSize=newSize;
    }
//调整预留的空间，也就是实际上申请的内存的大小
    void reserve(int newCapacity){
        if(newCapacity<theSize)
            return;
        T* oldObject=objects;
        objects=new T[newCapacity];
        theCapacity=newCapacity;
        for(int i=0;i<theSize;i++)
            objects[i]=oldObject[i];
        delete []oldObject;
        oldObject = NULL;
    }
//push和pop操作
    void push_back(T t){
        if(theSize==theCapacity)
            reserve(theCapacity*2+1);
        objects[theSize++]=t;
    }
    void pop_back(){
        theSize--;
    }
    T& back(){
        return objects[theSize-1];
    }
    const T& back()const{
        return objects[theSize-1];
    }

// 重载=号操作符
    const Vector& operator=(const Vector& rhs){
        theCapacity=rhs.theCapacity;
        theSize=rhs.theSize;
        objects=new objects[this->theCapacity];
        for(int i=0;i<this->theSize;i++)
            objects[i]=rhs.objects[i];
        return *this;
    }

//重载[]操作符
    T& operator[](int index){
        return *(objects+index);
    }
    const T& operator[](int index)const{
        return *(objects+index);
    }
//几个get函数，均为const成员，保证const对象也能调用
    bool isEmpty() const{
        return getSize()==0;
    }
    int capacity() const{
        return theCapacity;
    }
    int size() const{
        return theSize;
    }

// 迭代器
    typedef T* iterater;
    typedef const T* const_iterater;

//begin end 等操作
    iterater begin(){
        return objects;
    }
    const_iterater begin() const{
        return objects;
    }
    iterater end(){
        return (objects+theSize);
    }
    const_iterater end() const{
        return (objects+theSize);
    }
    enum { SPACE_CAPACITY=16};
private:
    T* objects;
    int theSize;
    int theCapacity;
};
```
## 读者写者问题
```C++
class Counter {
public:
  Counter() : value_(0) {
  }

  // Multiple threads/readers can read the counter's value at the same time.
  std::size_t Get() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return value_;
  }

  // Only one thread/writer can increment/write the counter's value.
  void Increase() {
    // You can also use lock_guard here.
    std::unique_lock<std::shared_mutex> lock(mutex_);
    value_++;
  }

  // Only one thread/writer can reset/write the counter's value.
  void Reset() {
    std::unique_lock<std::shared_mutex> lock(mutex_);
    value_ = 0;
  }

private:
  mutable std::shared_mutex mutex_;
  std::size_t value_;
};

////测试代码：！
std::mutex g_io_mutex;
void Worker(Counter& counter) {
  for (int i = 0; i < 3; ++i) {
    counter.Increase();
    std::size_t value = counter.Get();

    std::lock_guard<std::mutex> lock(g_io_mutex);
    std::cout << std::this_thread::get_id() << ' ' << value << std::endl;
  }
}

int main() {
  const std::size_t SIZE = 2;

  Counter counter;

  std::vector<std::thread> v;
  v.reserve(SIZE);

  v.emplace_back(&Worker, std::ref(counter));
  v.emplace_back(&Worker, std::ref(counter));

  for (std::thread& t : v) {
    t.join();
  }

  return 0;
}
```
2.自己的实现
```C++
#include <iostream>
using namespace std;

template<class T>
class lqh_vector{
public:
    lqh_vector(int size=0):size(size),capcity(16){
        lqh_vec = new T[capcity];
    }
    lqh_vector(const lqh_vector& temp){
        size = temp.size;
        capcity = temp.capcity;
        lqh_vec = new T[capcity];
        for(int i=0;i<size;i++){
            lqh_vec[i] = temp.lqh_vec[i];
        }
    }
    ~lqh_vector(){
        if(!lqh_vec == NULL){
            delete[] lqh_vec;
        }
        lqh_vec = NULL;
    }
    void reserve(int newcapcity);
    void push_back(T num);
    void delete_num(T num);
public:
    T* lqh_vec;
    int size;
    int capcity;
};

template <class T>
void lqh_vector<T>::reserve(int newcapcity){
    T* old_num = lqh_vec;
    lqh_vec = new T[newcapcity];
    capcity = newcapcity;
    for(int i=0;i<size;i++){
        lqh_vec[i] = old_num[i];
    }
    delete[] old_num;
    old_num = NULL;
}
template <class T>
void lqh_vector<T>::push_back(T num){
    lqh_vec[size++] = num;
    if(size==capcity){
        reserve(2*capcity+1);
    }
}

template <class T>
void lqh_vector<T>::delete_num(T num) {
    T* temp = lqh_vec;
    lqh_vec = new T[capcity];
    int newsize=0;
    int i=0,j=0;
    for(;i<size;i++){
        if(temp[i] != num){
            lqh_vec[j++] = temp[i];
            newsize++;
        }
    }
    size = newsize;
    delete[] temp;
    temp = NULL;
}
int main() {
    lqh_vector<int> test1;
    for(int i=0;i<17;i++){
        test1.push_back(i);
    }
    test1.delete_num(2);
    cout<<test1.size<<" "<<test1.capcity<<endl;
    for(int i=0;i<test1.size;i++){
        cout<<test1.lqh_vec[i]<<endl;
    }
    return 0;
}
```

## 二叉查找树的实现
[全部实现在这篇文章](https://www.cnblogs.com/skywang12345/p/3576373.html)

1.二叉树的结构和声明
```C++
template <class T>
class BSTNode{
    public:
        T key;            // 关键字(键值)
        BSTNode *left;    // 左孩子
        BSTNode *right;    // 右孩子
        BSTNode *parent;// 父结点//可以不要
        BSTNode(T value, BSTNode *p, BSTNode *l, BSTNode *r):
            key(value),parent(),left(l),right(r) {}
};
template <class T>
class BSTree {
    private:
        BSTNode<T> *mRoot;    // 根结点
    public:
        BSTree();
        ~BSTree();
        // 前序遍历"二叉树"
        void preOrder();
        // 中序遍历"二叉树"
        void inOrder();
        // 后序遍历"二叉树"
        void postOrder();
        // (递归实现)查找"二叉树"中键值为key的节点
        BSTNode<T>* search(T key);
        // (非递归实现)查找"二叉树"中键值为key的节点
        BSTNode<T>* iterativeSearch(T key);
        // 查找最小结点：返回最小结点的键值。
        T minimum();
        // 查找最大结点：返回最大结点的键值。
        T maximum();
        // 找结点(x)的后继结点。即，查找"二叉树中数据值大于该结点"的"最小结点"。
        BSTNode<T>* successor(BSTNode<T> *x);
        // 找结点(x)的前驱结点。即，查找"二叉树中数据值小于该结点"的"最大结点"。
        BSTNode<T>* predecessor(BSTNode<T> *x);
        // 将结点(key为节点键值)插入到二叉树中
        void insert(T key);
        // 删除结点(key为节点键值)
        void remove(T key);
        // 销毁二叉树
        void destroy();
        // 打印二叉树
        void print();
    private:
        // 前序遍历"二叉树"
        void preOrder(BSTNode<T>* tree) const;
        // 中序遍历"二叉树"
        void inOrder(BSTNode<T>* tree) const;
        // 后序遍历"二叉树"
        void postOrder(BSTNode<T>* tree) const;
        // (递归实现)查找"二叉树x"中键值为key的节点
        BSTNode<T>* search(BSTNode<T>* x, T key) const;
        // (非递归实现)查找"二叉树x"中键值为key的节点
        BSTNode<T>* iterativeSearch(BSTNode<T>* x, T key) const;
        // 查找最小结点：返回tree为根结点的二叉树的最小结点。
        BSTNode<T>* minimum(BSTNode<T>* tree);
        // 查找最大结点：返回tree为根结点的二叉树的最大结点。
        BSTNode<T>* maximum(BSTNode<T>* tree);
        // 将结点(z)插入到二叉树(tree)中
        void insert(BSTNode<T>* &tree, BSTNode<T>* z);
        // 删除二叉树(tree)中的结点(z)，并返回被删除的结点
        BSTNode<T>* remove(BSTNode<T>* &tree, BSTNode<T> *z);
        // 销毁二叉树
        void destroy(BSTNode<T>* &tree);
        // 打印二叉树
        void print(BSTNode<T>* tree, T key, int direction);
};
```
2.查找"二叉树x"中键值为key的节点
```C++
//递归版本
template <class T>
BSTNode<T>* BSTree<T>::search(BSTNode<T>* x, T key) const
{
    if (x==NULL || x->key==key)
        return x;

    if (key < x->key)
        return search(x->left, key);
    else
        return search(x->right, key);
}
template <class T>
BSTNode<T>* BSTree<T>::search(T key) 
{
    search(mRoot, key);
}
//非递归版本
template <class T>
BSTNode<T>* BSTree<T>::iterativeSearch(BSTNode<T>* x, T key) const
{
    while ((x!=NULL) && (x->key!=key))
    {
        if (key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    return x;
}
template <class T>
BSTNode<T>* BSTree<T>::iterativeSearch(T key)
{
    iterativeSearch(mRoot, key);
}
```
3.插入节点
```C++
/* 
 * 将结点插入到二叉树中
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     z 插入的结点
 */
template <class T>
void BSTree<T>::insert(BSTNode<T>* &tree, BSTNode<T>* z)
{
    BSTNode<T> *y = NULL;
    BSTNode<T> *x = tree;

    // 查找z的插入位置
    while (x != NULL)
    {
        y = x;
        if (z->key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    z->parent = y;//可以不要
    if (y==NULL)
        tree = z;
    else if (z->key < y->key)
        y->left = z;
    else
        y->right = z;
}

/* 
 * 将结点(key为节点键值)插入到二叉树中
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     key 插入结点的键值
 */
template <class T>
void BSTree<T>::insert(T key)
{
    BSTNode<T> *z=NULL;

    // 如果新建结点失败，则返回。
    if ((z=new BSTNode<T>(key,NULL,NULL,NULL)) == NULL)
        return ;

    insert(mRoot, z);
}
```
4.删除节点
```C++
/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     z 删除的结点
 */
template <class T>
BSTNode<T>* BSTree<T>::remove(BSTNode<T>* &tree, BSTNode<T> *z)
{
    BSTNode<T> *x=NULL;
    BSTNode<T> *y=NULL;

    if ((z->left == NULL) || (z->right == NULL) )
        y = z;
    else
        y = successor(z);

    if (y->left != NULL)
        x = y->left;
    else
        x = y->right;

    if (x != NULL)
        x->parent = y->parent;

    if (y->parent == NULL)
        tree = x;
    else if (y == y->parent->left)
        y->parent->left = x;
    else
        y->parent->right = x;

    if (y != z) 
        z->key = y->key;

    return y;
}

/* 
 * 删除结点(z)，并返回被删除的结点
 *
 * 参数说明：
 *     tree 二叉树的根结点
 *     z 删除的结点
 */
template <class T>
void BSTree<T>::remove(T key)
{
    BSTNode<T> *z, *node; 

    if ((z = search(mRoot, key)) != NULL)
        if ( (node = remove(mRoot, z)) != NULL)
            delete node;
}
```
## string的简单实现
